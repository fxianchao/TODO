# ç®—æ³•

## 1æ•°ç»„(Array)&é“¾è¡¨(Linked List)

1. æ•°ç»„:æ”¯æŒéšæœºè®¿é—®,ä½†æ˜¯æ’å…¥å’Œåˆ é™¤å¤æ‚
2. é“¾è¡¨:æ’å…¥å’Œåˆ é™¤æ–¹ä¾¿,ä½†æ˜¯ä¸æ”¯æŒéšæœºè®¿é—®

### 206åè½¬é“¾è¡¨

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

"""
# è§£æ³•ä¸€

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆè¿­ä»£
        pre = None
        cur = head
        
        while cur:
            nextTemp = cur.next
            cur.next = pre
            pre = cur
            cur = nextTemp
        
        return pre

"""


# è§£æ³•äºŒ

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆè¿­ä»£
        pre = None
        cur = head
        
        while cur:
            # åˆ©ç”¨pythonå¾ªç¯èµ‹å€¼ç‰¹æ€§,å»æ‰ä¸­é—´å˜é‡
            pre, cur.next, cur = cur, pre, cur.next
    
        return pre
```

### 24ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        pre, pre.next = self, head
        
        while pre.next and pre.next.next:
            # cur = pre.next
            # n = cur.next
            # nn = n.next
            # pre.next = n
            # n.next = cur
            # cur.next = nn
            # pre = cur
            
            cur = pre.next
            n = cur.next
            pre.next, n.next, cur.next = n, cur, n.next
            pre = cur
            
        return self.next
```

### 141ç¯å½¢é“¾è¡¨

```py
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

"è§£æ³•ä¸€"

# class Solution(object):
#     def hasCycle(self, head):
#         """
#         :type head: ListNode
#         :rtype: bool
#         """
#         fast = slow = head
        
#         while slow and fast and fast.next:
#             slow = slow.next
#             fast = fast.next.next
#             if slow is fast:
#                 return True
        
#         return False
    

"è§£æ³•äºŒ"

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        s = set()
        while head:
            if head in s:
                return True
            s.add(head)
            head = head.next
        
        return False
```

## 2å †æ ˆ(Stack)&é˜Ÿåˆ—(Queue)

1. æ ˆ:å…ˆå…¥åå‡º
2. é˜Ÿåˆ—:å…ˆå…¥å…ˆå‡º
3. ä¼˜å…ˆé˜Ÿåˆ—(PriorityQueue):æ­£å¸¸å…¥,æŒ‰ç…§ä¼˜å…ˆçº§å‡º
   1. å®ç°æœºåˆ¶
      1. å †(äºŒå‰å †,å¤šé¡¹å¼å †,æ–æ³¢é‚£å¥‘å †),æ ¹èŠ‚ç‚¹å¤§äº(å°äº)å·¦å³èŠ‚ç‚¹
      2. äºŒå‰æœç´¢æ ‘

### 20æœ‰æ•ˆçš„æ‹¬å·

```py
class Solution:
    def isValid(self, s: str) -> bool:
        stack = list()
        items = {"}":"{", "]":"[", ")":"("}
        for c in s:
            if c not in items:
                stack.append(c)
            elif not stack:
                return False
            elif items.get(c, None) != stack.pop():
                return False
        return not stack
```

### 232ç”¨æ ˆå®ç°é˜Ÿåˆ—

```py
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = list()
        self.s2 = list()
        

    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.s1.append(x)
        

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        if not self.s2:
            for i in range(len(self.s1)):
                self.s2.append(self.s1.pop())
        return self.s2.pop()
        
        
    def peek(self) -> int:
        """
        Get the front element.
        """
        if not self.s2:
            for i in range(len(self.s1)):
                self.s2.append(self.s1.pop())
        return self.s2[-1]
        

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return not(self.s1 or self.s2)
        


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```

### 225ç”¨é˜Ÿåˆ—å®ç°æ ˆ

```py
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = list()
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue.append(x)
        

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue.pop()
        

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[-1]
        
        
    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue
        


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
```

### 703æ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ 

```py
"è§£æ³•ä¸€"

# from queue import PriorityQueue as pq
# class KthLargest:

#     def __init__(self, k: int, nums: List[int]):
#         self.pq = pq()
#         self.k = k
#         for i in nums:
#             self.pq.put(i)
#             if (self.pq.qsize())>k:
#                 self.pq.get()
        

#     def add(self, val: int) -> int:
#         self.pq.put(val);
#         if (self.pq.qsize())>self.k:
#             self.pq.get()
#         ret = self.pq.get()
#         self.pq.put(ret)
#         return ret

"è§£æ³•äºŒ"

import heapq
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        heapq.heapify(nums)
        self.hp = nums
        self.k = k
        while len(self.hp)>k:
            heapq.heappop(self.hp)
        

    def add(self, val: int) -> int:
        if len(self.hp)<self.k:
            heapq.heappush(self.hp,val)
        elif self.hp[0]<val:
            heapq.heapreplace(self.hp,val)
        return self.hp[0]


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
```

### 239æ»‘åŠ¨çª—å£æœ€å¤§å€¼

```py
import heapq
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if not nums or k == 1:
            return nums
        
        """
        "è§£æ³•ä¸€"
        return [max(nums[i:i+k]) for i in range(len(nums)-k+1)]
        """
        
        """
        "è§£æ³•äºŒ"
        buf = list()
        ma = list()
        for i in range(len(nums)):
            if i<k:
                heapq.heappush(buf,nums[i])
                if i==k-1:
                    ma.append(heapq.nlargest(1,buf)[0])
                else:
                    pass
            else:
                buf.remove(nums[i-k])
                heapq.heappush(buf,nums[i])
                ma.append(heapq.nlargest(1,buf)[0])
        
        return ma
        
        """
        
        
        "è§£æ³•ä¸‰"
        ma = list()
        dq = deque()
        for i in range(len(nums)):
            # æ–°åˆ°çš„å…ƒç´ æ¯”é˜Ÿåˆ—å°¾éƒ¨å…ƒç´ å¤§åˆ™å‰”é™¤é˜Ÿåˆ—å°¾éƒ¨å…ƒç´ 
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()
            # æ·»åŠ æ–°å…ƒç´ æ—¶ä¿å­˜æ•°ç»„ä¸‹æ ‡,é¿å…æ•°ç»„ä¸­å­˜åœ¨é‡å¤å…ƒç´ æ—¶æ— æ³•è·å–å…ƒç´ ä¸‹æ ‡
            dq.append(i)
            # å½“é˜Ÿé¦–å…ƒç´ è¶…å‡ºçª—å£èŒƒå›´æ—¶ç§»é™¤é˜Ÿé¦–å…ƒç´ 
            if dq[0] == i-k:
                dq.popleft()
            # ä»çª—å£è¢«å¡«æ»¡å¼€å§‹,è®°å½•é˜Ÿé¦–å…ƒç´ å³çª—å£ä¸­æœ€å¤§å€¼
            if i >= k-1:
                ma.append(nums[dq[0]])

        return ma
```

## 3æ˜ å°„(Map)&é›†åˆ(Set)

1. å“ˆå¸Œå‡½æ•°
2. å“ˆå¸Œç¢°æ’:é“¾è¡¨è§£å†³
3. å“ˆå¸Œå’ŒäºŒå‰æœç´¢æ ‘å®ç°æ˜ å°„å’Œé›†åˆ
4. æ˜ å°„:é”®å€¼å¯¹
5. é›†åˆ:é”®å’Œå€¼ç›¸åŒ

### 242æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯

```py
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
        # "è§£æ³•ä¸€"
        # return sorted(s) == sorted(t)

       
        # "è§£æ³•äºŒ"
        # dict1 = dict()
        # dict2 = dict()
        # for c in s:
        #     dict1[c] = dict1.get(c,0) + 1
        # for c in t:
        #     dict2[c] = dict2.get(c,0) + 1
        # return dict1 == dict2
        
        "è§£æ³•ä¸‰"
        ls = [0]*26
        for c in s:
            ls[ord(c)-ord('a')] += 1
        for c in t:
            ls[ord(c)-ord('a')] -= 1
        
        return [_ for _ in ls if _ != 0] == []
```

### 1ä¸¤æ•°ä¹‹å’Œ

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        # "è§£æ³•ä¸€"
        # for i in range(len(nums)-1):
        #     for j in range(i+1,len(nums)):
        #         if nums[i]+nums[j] == target:
        #             return [i,j]

        "è§£æ³•äºŒ"
        dic = dict()
        for i in range(len(nums)):
            j = dic.get(target - nums[i], None)
            if j is not None:
                return [j,i]
            dic[nums[i]] = i
```

### 15 ä¸‰æ•°ä¹‹å’Œ

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if len(nums)<3:
            return []

        res = set()
        nums.sort()
        
        "è§£æ³•ä¸€"
        # for i in range(len(nums)-2):
        #     for j in range(i+1,len(nums)-1):
        #         for k in range(j+1,len(nums)):
        #             if nums[i]+nums[j]+nums[k] == 0:
        #                 res.add((nums[i],nums[j],nums[k]))
        # return res
        
        "è§£æ³•äºŒ"
        # for i, v in enumerate(nums[:-2]):
        #     if i >= 1 and nums[i] == nums[i-1]:
        #         continue
        #     d = dict()
        #     for x in nums[i+1:]:
        #         if x not in d:
        #             d[-v-x] = 1
        #         else:
        #             res.add((v,-v-x,x))
        # return res 
        
        "è§£æ³•ä¸‰"
        for i, v in enumerate(nums[:-2]):
            if i >= 1 and nums[i] == nums[i-1]:
                continue
            l = i+1
            r = len(nums)-1
            while l<r:
                su = v + nums[l] + nums[r]
                if su > 0:
                    r -= 1
                elif su < 0:
                    l += 1
                else:
                    res.add((v,nums[l],nums[r]))
                    while l < r and nums[l] == nums[l+1]:
                        l += 1
                    while l < r and nums[r] == nums[r-1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res
```

## 4æ ‘(Tree)&äºŒå‰æ ‘(Binary Tree)&äºŒå‰æœç´¢æ ‘(Binary Search Tree)

1. é“¾è¡¨ç»“æ„ä¸­æ·»åŠ ä¸€ä¸ªnextæŒ‡é’ˆ,å¾—åˆ°ä¸€æ£µäºŒå‰æ ‘
2. äºŒå‰æœç´¢æ ‘(Binary Search Tree),ä¹Ÿç§°æœ‰åºäºŒå‰æ ‘(Ordered Binary Tree)æˆ–æ’åºäºŒå‰æ ‘(Sorted Binary Tree),æŒ‡ä¸€æ£µ`ç©ºæ ‘`æˆ–è€…æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„äºŒå‰æ ‘:
   1. `å·¦å­æ ‘`ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼
   2. `å³å­æ ‘`ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å¤§äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼
   3. é€’å½’çš„(Recursively),å·¦å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æŸ¥æ‰¾æ ‘

### 98éªŒè¯äºŒå‰æœç´¢æ ‘

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# "è§£æ³•ä¸€"
# class Solution:
#     def isValidBST(self, root: TreeNode) -> bool:
#         def inorder(root):
#             if root is None:
#                 return []
#             return inorder(root.left) + [root.val] + inorder(root.right)
            
#         order = inorder(root)
#         return order == sorted(set(order))
        

# "è§£æ³•äºŒ"
# class Solution:
#     def isValidBST(self, root: TreeNode) -> bool:
#         self.pre = None
#         def isBST(node):
#             if node is None:
#                 return True
#             if not isBST(node.left):
#                 return False
#             if self.pre and self.pre.val >= node.val:
#                 return False
#             self.pre = node
#             return isBST(node.right)
#         return isBST(root)
        

# "è§£æ³•ä¸‰"
# class Solution:
#     def isValidBST(self, root: TreeNode) -> bool:
#         stack = [(root,float("-inf"),float("inf")),]
#         while stack:
#             r,mi,ma = stack.pop()
#             if r is None:
#                 continue
#             if r.val>=ma or r.val<=mi:
#                 return False
#             stack.append((r.left,mi,r.val))
#             stack.append((r.right,r.val,ma))
#         return True
            

"è§£æ³•å››"
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def isBST(r,mi,ma):
            if r is None:
                return True
            if r.val>=ma or r.val<=mi:
                return False
            return isBST(r.left,mi,r.val) and isBST(r.right,r.val,ma)
        return isBST(root,float("-inf"),float("inf"))

```

### 236äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        "è§£æ³•ä¸€"
        # if root is None or root is p or root is q:
        #     return root
        # left = self.lowestCommonAncestor(root.left,p,q)
        # right = self.lowestCommonAncestor(root.right,p,q)
        # if left:
        #     if right:
        #         return root
        #     return left
        # return right
        
        
        "è§£æ³•äºŒ"
        stack = [root]
        parent_map = {root:None}
        while p not in parent_map or q not in parent_map:
            cur = stack.pop()
            if cur.left:
                parent_map[cur.left] = cur
                stack.append(cur.left)
            if cur.right:
                parent_map[cur.right] = cur
                stack.append(cur.right)
        ancestor = set()
        while p:
            ancestor.add(p)
            p = parent_map[p]
        while q not in ancestor:
            q = parent_map[q]
        return q
```

### 235äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        "è§£æ³•ä¸€"
        # if root is None or root is p or root is q:
        #     return root
        # left = self.lowestCommonAncestor(root.left,p,q)
        # right = self.lowestCommonAncestor(root.right,p,q)
        # if left:
        #     if right:
        #         return root
        #     return left
        # return right
        
        "è§£æ³•äºŒ"
        # if root is None:
        #     return root
        # if root.val < p.val and root.val < q.val:
        #     return self.lowestCommonAncestor(root.right,p,q)
        # if root.val > p.val and root.val > q.val:
        #     return self.lowestCommonAncestor(root.left,p,q)
        # return root
        
        
        "è§£æ³•ä¸‰"
        # while root:
        #     if root.val < p.val and root.val < q.val:
        #         root = root.right
        #     elif root.val > p.val and root.val > q.val:
        #         root = root.left
        #     else:
        #         return root
        
        "è§£æ³•å››"
        while (p.val-root.val)*(q.val-root.val) > 0:
            root = (root.left,root.right)[p.val>root.val]
        return root
```

## 5äºŒå‰æ ‘éå†(Binary Tree Travesal)

1. æ·±åº¦ä¼˜å…ˆæœç´¢ä¸­(DFS),æ ¹æ®æ ¹èŠ‚ç‚¹,å·¦å³èŠ‚ç‚¹çš„ç›¸å¯¹é¡ºåºåˆ†ä¸º
   1. å‰åº(Pre-order):æ ¹-å·¦-å³
   2. ä¸­åº(In-order):å·¦-æ ¹-å³
   3. ååº(Post-order):å·¦-å³-æ ¹

### 144äºŒå‰æ ‘çš„å‰åºéå†

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        "è§£æ³•ä¸€"
        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
    
        "è§£æ³•äºŒ"
        # stack = [root]
        # out = list()
        # while stack:
        #     node = stack.pop()
        #     if node is not None:
        #         out.append(node.val)
        #     if node.right is not None:
        #         stack.append(node.right)
        #     if node.left is not None:
        #         stack.append(node.left)
        # return out
    
        "è§£æ³•ä¸‰"
        out = list()
        def preorder(root):
            if root:
                out.append(root.val)
                preorder(root.left)
                preorder(root.right)
        preorder(root)
        return out
```

### 94äºŒå‰æ ‘çš„ä¸­åºéå†

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if root is None:
            return []
        
        "è§£æ³•ä¸€"
        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)
        
        "è§£æ³•äºŒ"
        stack, out, node = [], [], root
        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            node = stack.pop()
            out.append(node.val)
            node = node.right
        return out
            
        "è§£æ³•ä¸‰"
        # out = list()
        # def inorder(root):
        #     if root:
        #         inorder(root.left)
        #         out.append(root.val)
        #         inorder(root.right)
        # inorder(root)
        # return out
```

### 145äºŒå‰æ ‘çš„ååºéå†

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        
        "è§£æ³•ä¸€"
        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val] if root else []

        
        "è§£æ³•äºŒ"
        # out = list()
        # def hostorder(root):
        #     if root:
        #         hostorder(root.left)
        #         hostorder(root.right)
        #         out.append(root.val)
        # hostorder(root)
        # return out
        
        "è§£æ³•ä¸‰"
        if not root:
            return []
        stack, out = [root], []
        while stack:
            node = stack.pop()
            if node is not None:
                out.append(node.val)
            if node.left is not None:
                stack.append(node.left)
            if node.right is not None:
                stack.append(node.right)
        return out[::-1]
```

## 6é€’å½’(Recursion)&åˆ†æ²»(Divide&Conquer)

1. é€’å½’:ç»ˆæ­¢æ¡ä»¶,é€’æ¨å…¬å¼
2. åˆ†æ²»:ç»ˆæ­¢æ¡ä»¶,åˆ’åˆ†,å¤„ç†,åˆå¹¶

### 50Pow(x,n)

```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        
        "è§£æ³•ä¸€"
        # return x**n
    
    
        "è§£æ³•äºŒ:è¶…æ—¶"
        # if n < 0:
        #     x, n = 1/x, -n
        # res = 1
        # for i in range(n):
        #     res *= x
        # return res
      
    
        "è§£æ³•ä¸‰"
        # if n == 0:
        #     return 1
        # if n < 0:
        #     return 1 / self.myPow(x,-n)
        # if n%2:
        #     return x*self.myPow(x,n-1)
        #    # return x*self.myPow(x*x,n//2)
        # return self.myPow(x*x,n//2)
        
        
        "è§£æ³•å››"
        if n < 0:
            x, n = 1/x, -n
        pow = 1
        while n:
            if n&1:
                pow *= x  # ç›¸å½“äºn%2==1æ—¶,x*self.myPow(x,n-1)
            x *= x
            n >>= 1
        return pow
```

### 169æ±‚ä¼—æ•°

```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        
        "è§£æ³•ä¸€"
        # for i in set(nums):
        #     # if nums.count(i) > len(nums)//2:
        #     count = sum(1 for j in nums if j == i)
        #     if count > len(nums)//2:
        #         return i
        
        "è§£æ³•äºŒ"
        # dic = dict()
        # for i in nums:
        #     if i not in dic:
        #         dic[i] = 1
        #     else:
        #         dic[i] += 1
        # for i, v in dic.items():
        #     if v > len(nums)//2:
        #         return i
        # # return max(dic.keys(),key=dic.get)  # å­—å…¸æ ¹æ®å€¼å–é”®
        
        # counter = collections.Counter(nums)  # å€ŸåŠ©è®¡æ•°å™¨
        # return counter.most_common(1)[0][0]
        
        "è§£æ³•ä¸‰"
        # nums.sort()
        # # return nums[len(nums)//2]
        # pre = None
        # cnt = 1
        # for i in nums:
        #     if i == pre:
        #         cnt += 1
        #     else:
        #         pre = i
        #         cnt = 1
        #     if cnt > len(nums)//2:
        #         return i
        
        "è§£æ³•å››"
        # def majority(lo, hi):
        #     if lo == hi:
        #         return nums[lo]
        #     mid = lo + (hi-lo)//2
        #     left = majority(lo,mid)
        #     right = majority(mid+1,hi)
        #     if left == right:
        #         return left
        #     left_cnt = nums[lo:hi+1].count(left)
        #     right_cnt = nums[lo:hi+1].count(right)
        #     return left if left_cnt > right_cnt else right
        # return majority(0,len(nums)-1)
        
        "è§£æ³•äº”"
        # while True:
        #     rand = random.choice(nums)
        #     if nums.count(rand) > len(nums)//2:
        #         return rand
        
        "è§£æ³•å…­"
        # cnt = 0
        # candidate = None
        # for i in nums:
        #     if cnt == 0:
        #         candidate = i
        #         cnt += 1
        #     else:
        #         cnt += (1 if candidate == i else -1)
        # return candidate
        
        cnt = 0
        candidate = None
        for i in nums:
            if cnt == 0:
                candidate = i
            cnt += (1 if i == candidate else -1)
        return candidate
```

## 7è´ªå¿ƒç®—æ³•(Greedy)

1. åœ¨å¯¹é—®é¢˜æ±‚è§£æ—¶,æ€»æ˜¯åšå‡ºåœ¨å½“å‰çœ‹æ¥æ˜¯æœ€å¥½çš„é€‰æ‹©
2. é€‚ç”¨åœºæ™¯:é—®é¢˜èƒ½å¤Ÿåˆ†è§£æˆå­é—®é¢˜æ¥è§£å†³,å­é—®é¢˜çš„æœ€ä¼˜è§£èƒ½é€’æ¨åˆ°æœ€ç»ˆé—®é¢˜çš„æœ€ä¼˜è§£.è¿™ç§å­é—®é¢˜æœ€ä¼˜è§£ç§°ä¸º`æœ€ä¼˜å­ç»“æ„`
3. è´ªå¿ƒç®—æ³•å’ŒåŠ¨æ€è§„åˆ’çš„ä¸åŒ:è´ªå¿ƒç®—æ³•å¯¹æ¯ä¸ªå­é—®é¢˜éƒ½åšå‡ºé€‰æ‹©,`ä¸èƒ½å›é€€`.è€ŒåŠ¨æ€è§„åˆ’ä¼šä¿å­˜ä»¥å‰çš„è¿ç®—ç»“æœ,å¹¶æ ¹æ®ä»¥å‰çš„ç»“æœå¯¹å½“å‰è¿›è¡Œé€‰æ‹©,`æœ‰å›é€€åŠŸèƒ½`

### 122ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(len(prices)-1):
            cha = prices[i+1]-prices[i]
            if cha > 0:
                profit += cha
        return profit
```

## 8å¹¿åº¦ä¼˜å…ˆæœç´¢(BFS,Bready-First-Search)

1. ä¸éœ€è¦é€’å½’,ä½¿ç”¨é˜Ÿåˆ—å®ç°

```py
def BFS(graph,start,end):
    queue = list()  # ä½¿ç”¨åˆ—è¡¨æ¨¡æ‹Ÿé˜Ÿåˆ—
    queue.append(start)
    visited = set()  # ä½¿ç”¨é›†åˆä¿å­˜å·²è®¿é—®çš„å…ƒç´ ,æ ‘ä¸­ä¸éœ€è¦ä¿å­˜

    while queue:
        node = queue.pop(0)  # å¼¹å‡ºé˜Ÿé¦–å…ƒç´ 
        process(node)
        visited.add(node)

        nodes = generate_related_nodes(node)  # å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€å±‚èŠ‚ç‚¹,åœ¨å›¾ä¸­éœ€åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
        queue.append(nodes)
    other_processing_work()
```

### 102äºŒå‰æ ‘çš„å±‚æ¬¡éå†

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []
        
        "è§£æ³•ä¸€"
        # queue = collections.deque()
        # queue.append(root)
        # res = list()
        # # vistted = set()
        # while queue:
        #     le = len(queue)
        #     current_level = list()
        #     for _ in range(le):
        #         node = queue.popleft()
        #         current_level.append(node.val)
        #         if node.left:
        #             queue.append(node.left)
        #         if node.right:
        #             queue.append(node.right)
        #     res.append(current_level)
        # return res
        
        "è§£æ³•äºŒ"
        res = list()
        def _DFS(node,level):
            if not node:
                return
            if len(res) < level + 1:
                res.append([])
            res[level].append(node.val)
            _DFS(node.left,level + 1)
            _DFS(node.right,level + 1)
        _DFS(root,0)
        return res
```

### 104äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        "è§£æ³•ä¸€"
        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
    
        "è§£æ³•äºŒ"
        # queue = collections.deque()
        # queue.append(root)
        # ma = 0
        # while queue:
        #     le = len(queue)
        #     for i in range(le):
        #         node = queue.popleft()
        #         if node.left:queue.append(node.left)
        #         if node.right:queue.append(node.right)
        #     ma += 1
        # return ma
        
        "è§£æ³•ä¸‰"
        self.ma = 0
        def DFS(node,level):
            if node is None:
                return
            self.ma = max(self.ma,level+1)
            DFS(node.left,level+1)
            DFS(node.right,level+1)
        DFS(root,0)
        return self.ma
```

### 111äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        
        "è§£æ³•ä¸€"
        # if root is None:
        #     return 0
        # if root.left is None:
        #     return 1 + self.minDepth(root.right)
        # if root.right is None:
        #     return 1 + self.minDepth(root.left)
        # return 1 + min(self.minDepth(root.right), self.minDepth(root.left))
        
        "è§£æ³•äºŒ"
        # if root is None:
        #     return 0
        # queue = collections.deque()
        # queue.append(root)
        # mi = 0
        # while queue:
        #     le = len(queue)
        #     for _ in range(le):
        #         node = queue.popleft()
        #         if node.left is None and node.right is None:
        #             return mi + 1
        #         if node.left: queue.append(node.left)
        #         if node.right:queue.append(node.right)
        #     mi += 1
        
        "è§£æ³•ä¸‰"
        if root is None:
            return 0
        self.mi = float("inf")
        def DFS(node,level):
            if node is None:
                return
            if node.left is None and node.right is None:
                self.mi = min(self.mi, level + 1)
            DFS(node.left,level+1)
            DFS(node.right,level+1)
        DFS(root,0)
        return self.mi
```

### 22æ‹¬å·ç”Ÿæˆ

```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        
        "è§£æ³•ä¸€"
        # def gen(left, right, st, res):
        #     if left == 0 and right == 0:
        #         res.append(st)
        #         return
        #     if left > 0:
        #         gen(left-1, right, st + "(", res)
        #     if right > left:
        #         gen(left, right - 1, st + ")", res)
        # result = list()
        # gen(n, n, "", result)
        # return result
    
        "è§£æ³•äºŒ"
        if n == 0:
            return [""]
        ans = list()
        for i in range(n):
            for left in self.generateParenthesis(i):
                for right in self.generateParenthesis(n-i-1):
                    ans.append(f"({left}){right}")
        return ans
```

## 9æ·±åº¦ä¼˜å…ˆæœç´¢(DFS,Depth-First-Search)

1. æœ‰é€’å½’ç‰ˆæœ¬å’Œéé€’å½’ç‰ˆæœ¬
2. é€’å½’ç‰ˆæœ¬ä»£ç ç®€å•
3. éé€’å½’ç‰ˆæœ¬éœ€è¦å€ŸåŠ©æ ˆæ¥å®ç°

```py
# é€’å½’ç‰ˆæœ¬
visited = set()
def DFS(node, visted):
    process(node)
    visited.add(node)
    for next_node in node.next_nodes():
        if next_node not in visited:
            DFS(next_node, visited)
```

```py
# éé€’å½’ç‰ˆæœ¬
def DFS(tree):
    visited, stack = set(), [tree.node]  # ä½¿ç”¨åˆ—è¡¨æ¨¡æ‹Ÿæ ˆ
    while stack:
        node = stack.pop()  # å¼¹å‡ºæ ˆé¡¶å…ƒç´ 
        process(node)
        visited.add(node)

        nodes = generate_related_nodes(node)
        stack.append(nodes)
    other_processing_work()
```

## 10å‰ªæ(Pruning)

1. åœ¨æœç´¢ä¸­å¸¸ç”¨çš„ä¼˜åŒ–ç­–ç•¥

### 51@Nçš‡å

```py
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def DFS(col, pie, na):
            i = len(col)
            if i >= n:
                result.append(col)
                return
            for j in range(n):
                if j not in col and i+j not in pie and i-j not in na:
                    DFS(col + [j], pie + [i+j], na + [i-j])
        result = list()
        DFS([], [], [])
        return [["."*j + "Q" + "."*(n-j-1) for j in col] for col in result]
```

### 52@Nçš‡åII

```py
class Solution:
    def totalNQueens(self, n: int) -> int:
        def DFS(col, pie, na):
            i = len(col)
            if i >= n:
                self.res += 1
                return
            for j in range(n):
                if j not in col and i+j not in pie and i-j not in na:
                    DFS(col+[j], pie+[i+j], na+[i-j])
        self.res = 0
        DFS([], [], [])
        return self.res
```

### 36æœ‰æ•ˆçš„æ•°ç‹¬

```py
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        
        "è§£æ³•ä¸€"
        # for i in range(9):
        #     for j in range(9):
        #         ele = board[i][j]
        #         if ele != ".":
        #             for k in range(9):
        #                 if k != j and board[i][k] == ele:
        #                     return False
        #                 if k != i and board[k][j] == ele:
        #                     return False
        #                 row = 3 * (i // 3) + (k // 3)
        #                 col = 3 * (j // 3) + (k % 3)
        #                 if row != i and col != j and board[row][col] == ele:
        #                     return False
        # return True
        
        "è§£æ³•äºŒ"
        # rows = [{} for i in range(9)]
        # columns = [{} for i in range(9)]
        # boxes = [{} for i in range(9)]
        # for i in range(9):
        #     for j in range(9):
        #         num = board[i][j]
        #         if num != '.':
        #             # num = int(num)
        #             box_index = (i // 3 ) * 3 + j // 3
        #             rows[i][num] = rows[i].get(num, 0) + 1
        #             columns[j][num] = columns[j].get(num, 0) + 1
        #             boxes[box_index][num] = boxes[box_index].get(num, 0) + 1
        #             if rows[i][num] > 1 or columns[j][num] > 1 or boxes[box_index][num] > 1:
        #                 return False         
        # return True
        
        "è§£æ³•ä¸‰"
        row = [[x for x in y if x != '.'] for y in board]
        col = [[x for x in y if x != '.'] for y in zip(*board)]
        pal = [[board[i+m][j+n] for m in range(3) for n in range(3) if board[i+m][j+n] != '.'] for i in (0, 3, 6) for j in (0, 3, 6)]
        return all(len(set(x)) == len(x) for x in (*row, *col, *pal))
```

### 37è§£æ•°ç‹¬

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        self.solved = False
        num = list("123456789")
        def isValied(i, j, c):
            for k in range(9):
                if board[i][k] == c:
                    return False
                if board[k][j] == c:
                    return False
                if board[3*(i//3)+k//3][3*(j//3)+k%3] == c:
                    return False
            return True
        def DFS(index,):
            if index >= 81:
                self.solved = True
                return
            i = index//9
            j = index%9
            if board[i][j] == ".":
                for c in num:
                    if isValied(i,j,c):
                        board[i][j] = c
                        DFS(index+1)
                        if self.solved is False:
                            board[i][j] = "."
            else:
                DFS(index+1)
        DFS(0)
```

## 11äºŒåˆ†æŸ¥æ‰¾(Binary Search)

1. Sorted
2. Bounded
3. Accessible by index

```py
left, right = 0, len(arr) - 1
while left <= right:
    mid = (right + left)//2
    if arr[mid] == target:
        return 
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

### 69@xçš„å¹³æ–¹æ ¹

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        
        "è§£æ³•ä¸€"
        # return int(math.sqrt(x))
        
        "è§£æ³•äºŒ"
        # if x == 0 or x == 1:
        #     return x
        # left, right = 1, x
        # res = 0
        # while left <= right:
        #     mid = (right + left)//2
        #     square = mid*mid
        #     if square == x:
        #         return mid
        #     elif square > x:
        #         right = mid-1
        #     else:
        #         left = mid + 1
        #         res = mid
        # return res
        
        "è§£æ³•ä¸‰"
        if x == 0:
            return 0
        cur = 1
        while True:
            pre = cur
            cur = (cur + x / cur) / 2
            if abs(cur-pre) < 1E-6:
                return int(cur)
```

## 12å­—å…¸æ ‘(Trie)

1. Trieæ ‘çš„åŸºæœ¬ç»“æ„
   1. åˆç§°å•è¯æŸ¥æ‰¾æ ‘æˆ–é”®æ ‘,æ˜¯ä¸€ç§æ ‘å½¢ç»“æ„,æ˜¯ä¸€ç§å“ˆå¸Œæ ‘çš„å˜ç§
   2. å…¸å‹åº”ç”¨æ˜¯ç”¨äºç»Ÿè®¡å’Œæ’åºå¤§é‡çš„å­—ç¬¦ä¸²(ä¸é™äºå­—ç¬¦ä¸²),ç»å¸¸è¢«æœç´¢å¼•æ“ç”¨äºæ–‡æœ¬è¯é¢‘ç»Ÿè®¡
   3. ä¼˜ç‚¹:æœ€å¤§é™åº¦çš„å‡å°‘æ— è°“çš„å­—ç¬¦ä¸²æ¯”è¾ƒ,æŸ¥æ‰¾æ•ˆç‡æ¯”å“ˆå¸Œè¡¨é«˜
2. Trieæ ‘çš„æ ¸å¿ƒæ€æƒ³
   1. ç©ºé—´æ¢å–æ—¶é—´.åˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥é™ä½æŸ¥è¯¢æ—¶é—´çš„å¼€é”€ä»¥è¾¾åˆ°æé«˜æ•ˆç‡çš„ç›®çš„
3. Trieæ ‘çš„åŸºæœ¬æ€§è´¨
   1. æ ¹èŠ‚ç‚¹ä¸åŒ…å«å­—ç¬¦,é™¤æ ¹èŠ‚ç‚¹å¤–æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½åªåŒ…å«ä¸€ä¸ªå­—ç¬¦
   2. ä»æ ¹èŠ‚ç‚¹åˆ°æŸä¸€èŠ‚ç‚¹,è·¯å¾„ä¸Šç»è¿‡çš„å­—ç¬¦æ‹¼æ¥èµ·æ¥,ä¸ºè¯¥èŠ‚ç‚¹å¯¹åº”çš„å­—ç¬¦ä¸²
   3. æ¯ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹åŒ…å«çš„å­—ç¬¦éƒ½ä¸ç›¸åŒ
4. è§£å†³çš„å®é™…é—®é¢˜
   1. è§£å†³æœç´¢å¼•æ“ç³»ç»Ÿè®¾è®¡,æœç´¢å»ºè®®é—®é¢˜

### 208å®ç°Trie(å‰ç¼€æ ‘)

```py
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = dict()
        self.EOW = "#"        

    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        node = self.root
        for c in word:
            node = node.setdefault(c, dict())
        node[self.EOW] = self.EOW
        

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        node = self.root
        for c in word:
            node = node.get(c, None)
            if node is None:
                return False
        return self.EOW in node
        

    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        node = self.root
        for c in prefix:
            node = node.get(c, None)
            if node is None:
                return False
        return True
        


# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
```

### 212å•è¯æœç´¢II

```py
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:

        if not words:
            return []
        if not board or not board[0]:
            return []
        self.result = set()
        self.dx = [-1, 1, 0, 0]
        self.dy = [0, 0, -1, 1]
        self.EOW = "#"
        root = collections.defaultdict()
        for word in words:
            node = root
            for c in word:
                node = node.setdefault(c, collections.defaultdict())
            node[self.EOW] = self.EOW

        def DFS(i, j, cur_w, cur_dic):
            cur_w += board[i][j]
            cur_dic = cur_dic[board[i][j]]
            if self.EOW in cur_dic:
                self.result.add(cur_w)
            temp, board[i][j] = board[i][j], "@"
            for k in range(4):
                x, y = i + self.dx[k], j + self.dy[k]
                if 0 <= x < self.m and 0 <= y < self.n and board[x][y] != "@" and board[x][y] in cur_dic:
                    DFS(x, y, cur_w, cur_dic)
            board[i][j] = temp

        self.m = len(board)
        self.n = len(board[0])
        for i in range(self.m):
            for j in range(self.n):
                if board[i][j] in root:
                    DFS(i, j, "", root)
        return self.result
```

## 13ä½è¿ç®—(Bit)

1. ä½è¿ç®—ä»‹ç»
   1. æ•°æ®åœ¨å†…å­˜ä¸­ä»¥äºŒè¿›åˆ¶å­˜å‚¨,ä½è¿ç®—ç›´æ¥æ“ä½œå†…å­˜ä¸­çš„äºŒè¿›åˆ¶,å¤„ç†é€Ÿåº¦å¿«
2. ä½è¿ç®—å¸¸ç”¨æ“ä½œ
   1. ä¸
   2. æˆ–
   3. å¼‚æˆ–:åŒ1å¼‚0,å¯ç”¨ä¸è¿›ä½åŠ æ³•ç†è§£
      1. `x ^ 0 = x` 
      2. `x ^ 1s = ~x` 
      3. `x ^ (~x) = 1s` 
      4. `x ^ x = 0` 
      5. `a ^ b = c --> a ^ c = b, b ^ c = a`
      6. `a ^ b ^ c = a ^(b ^ c) = (a ^ b) ^ c` 
   4. å–å
   5. å·¦ç§»
   6. å³ç§»
   7. å®æˆ˜å¸¸ç”¨çš„æ“ä½œ
      1. `X & 1 == 1 or == 0`åˆ¤æ–­å¥‡å¶æ€§(x%2==1)
      2. `x = x&(x-1)`æ¸…é›¶æœ€ä½ä½çš„1
      3. `x&(-x)`å¾—åˆ°æœ€ä½ä½çš„1
3. ä½è¿ç®—çš„åº”ç”¨
   1. å°†xæœ€å³è¾¹çš„nä½æ¸…é›¶`x&(~0<<n)`
   2. è·å–xçš„ç¬¬nä½çš„å€¼`(x>>n)&1`
   3. è·å–xçš„ç¬¬nä½çš„å¹‚å€¼`x&(1<<(n-1))`
   4. ä»…å°†ç¬¬nä½ç½®1`x|(1<<n)`
   5. ä»…å°†ç¬¬nä½ç½®0`x&(~(1<<n))`
   6. å°†xæœ€é«˜ä½è‡³ç¬¬nä½(åŒ…å«)æ¸…é›¶`x&((1<<n)-1)`
   7. å°†xç¬¬nä½è‡³ç¬¬0ä½(åŒ…å«)æ¸…é›¶`x&(~((1<<(n+1))-1))`

### 191ä½1çš„ä¸ªæ•°

```py
class Solution(object):
    def hammingWeight(self, n):
        """
        :type n: int
        :rtype: int
        """
        "è§£æ³•ä¸€"
        # res = 0
        # while n:
        #     if n%2==1:
        #         res+=1
        #     n>>=1
        # return res
        
        "è§£æ³•äºŒ"
        res = 0
        while n:
            n = n&(n-1)
            res += 1
        return res
```

### 231@2çš„å¹‚

```py
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n>0 and not n&(n-1)
```

### 338æ¯”ç‰¹ä½è®¡æ•°

```py
class Solution:
    def countBits(self, num: int) -> List[int]:
        ls = [0]
        for i in range(1,num+1):
            ls.append(0)
            "è§£æ³•ä¸€"
            ls[i] = ls[i>>1]+(i&1)  # æœ€ä½æœ‰æ•ˆä½
            "è§£æ³•äºŒ"
            # ls[i] = ls[i&(i-1)]+1  # æœ€ä½è®¾ç½®ä½
            "è§£æ³•ä¸‰"
            # æœ€é«˜æœ‰æ•ˆä½
            "è§£æ³•å››"
            # æŒ¨ä¸ªæ±‚
        return ls
```

### 52@Nçš‡åII(ä½è¿ç®—ç‰ˆæœ¬)

```py
class Solution:
    def totalNQueens(self, n: int) -> int:
        "è§£æ³•ä¸€"
        # def DFS(col, pie, na):
        #     i = len(col)
        #     if i >= n:
        #         self.res += 1
        #         return
        #     for j in range(n):
        #         if j not in col and i+j not in pie and i-j not in na:
        #             DFS(col+[j], pie+[i+j], na+[i-j])
        # self.res = 0
        # DFS([], [], [])
        # return self.res
    
        "è§£æ³•äºŒ"
        if n < 0:
            return []
        def DFS_bit(row,col,pie,na):
            if row>=n:
                self.res += 1
                return
            bits = (~(col|pie|na)) & ((1<<n)-1)  # å–æœ‰æ•ˆçš„nä½
            while bits>0:
                p = bits&(-bits)  # å–æœ€ä½ä½çš„1
                DFS_bit(row+1, col|p, (pie|p)<<1, (na|p)>>1)
                bits &=(bits-1)  # åˆ æ‰æœ€ä½ä½çš„1
        self.res = 0
        DFS_bit(0,0,0,0)
        return self.res
```

## 14åŠ¨æ€è§„åˆ’(Dynamic Programming)

1. é€’å½’+è®°å¿†åŒ–->`é€’æ¨`
2. çŠ¶æ€çš„å®šä¹‰:`opt[ ],dp[ ],fib[ ]`
3. çŠ¶æ€è½¬ç§»æ–¹ç¨‹: `opt[n] = best_of(opt[n-1], opt[n-2])`
4. `æœ€ä¼˜å­ç»“æ„`
5. åŠ¨æ€è§„åˆ’vså›æº¯vsè´ªå¿ƒ
   1. å›æº¯(é€’å½’)-é‡å¤è®¡ç®—,æ²¡æœ‰æœ€ä¼˜å­ç»“æ„
   2. è´ªå¿ƒ-æ°¸è¿œå±€éƒ¨æœ€ä¼˜
   3. DP-è®°å½•å±€éƒ¨æœ€ä¼˜å­ç»“æ„/å¤šç§è®°å½•å€¼

### 70çˆ¬æ¥¼æ¢¯

```py
class Solution:
    def climbStairs(self, n: int) -> int:
        
        "è§£æ³•ä¸€"
        # def DFS(n):
        #     if n==0 or n==1:
        #         return 1
        #     return DFS(n-1)+DFS(n-2)
        
        "è§£æ³•äºŒ"
        # dic = dict()
        # dic[0] = 1
        # dic[1] = 1
        # def DFS_mem(n):
        #     if n in dic:
        #         return dic[n]
        #     else:
        #         dic[n] = DFS_mem(n-1)+DFS_mem(n-2)
        #         return dic[n]
        
        "è§£æ³•ä¸‰"
        def DP(n):
            x, y = 1, 1
            for _ in range(1,n):
                x, y = y, x+y
            return y
        return DP(n)
```

### 120ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ

```py
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        if not triangle:
            return 0
        mini = triangle[-1]
        for i in range(len(triangle)-2,-1,-1):
            for j in range(len(triangle[i])):
                mini[j] = min(mini[j],mini[j+1]) + triangle[i][j]
        return mini[0]
```

### 152ä¹˜ç§¯æœ€å¤§å­åºåˆ—

```py
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums: return 0
        # å®šä¹‰dp[i][0]ä¸ºä»0åˆ°iå¹¶ä¸”ä»¥iç»“å°¾æ—¶çš„ä¹˜ç§¯æœ€å¤§å€¼
        # å®šä¹‰dp[i][1]ä¸ºä»0åˆ°iå¹¶ä¸”ä»¥iç»“å°¾æ—¶çš„ä¹˜ç§¯æœ€å°å€¼
        dp =[[0 for j in range(2)] for i in range(len(nums))]
        dp[0][0] = dp[0][1] = nums[0]
        for i in range(1,len(nums)):
            dp[i][0] = max(dp[i-1][0]*nums[i],dp[i-1][1]*nums[i],nums[i])
            dp[i][1] = min(dp[i-1][0]*nums[i],dp[i-1][1]*nums[i],nums[i])
        maxi = list(zip(*dp))[0]
        return max(maxi)
```

### ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºç³»åˆ—

#### 121æœ€å¤šä¸€ç¬”äº¤æ˜“,æœ€å¤šä¸€æ”¯è‚¡ç¥¨

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
  
        "è§£æ³•ä¸‰"
        if not prices: return 0
        dp = [[0 for i in range(2)] for j in range(len(prices))]
        # å®šä¹‰dp[i][0]ä¸ºç¬¬iå¤©æ²¡æœ‰è‚¡ç¥¨æ—¶çš„æœ€å¤§åˆ©æ¶¦
        # å®šä¹‰dp[i][1]ä¸ºç¬¬iå¤©æœ‰ä¸€æ”¯è‚¡ç¥¨æ—¶çš„æœ€å¤§åˆ©æ¶¦
        # dp[n-1][0]å³ä¸ºæœ€åä¸€å¤©æ²¡æœ‰è‚¡ç¥¨æ—¶çš„æœ€å¤§åˆ©æ¶¦
        dp[0] = [0, -prices[0]]
        for i in range(1,len(prices)):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
            dp[i][1] = max(dp[i-1][1], -prices[i])
        return dp[len(prices)-1][0]
```

#### 122ä¸é™äº¤æ˜“æ¬¡æ•°,æœ€å¤šä¸€æ”¯è‚¡ç¥¨

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
    
        "è§£æ³•äºŒ"
        if not prices: return 0
        dp = [[0 for i in range(2)] for j in range(len(prices))]
        # å®šä¹‰dp[i][0]ä¸ºç¬¬iå¤©æ²¡æœ‰è‚¡ç¥¨æ—¶çš„æœ€å¤§åˆ©æ¶¦
        # å®šä¹‰dp[i][1]ä¸ºç¬¬iå¤©æœ‰ä¸€æ”¯è‚¡ç¥¨æ—¶çš„æœ€å¤§åˆ©æ¶¦
        # dp[n-1][0]å³ä¸ºæœ€åä¸€å¤©æ²¡æœ‰è‚¡ç¥¨æ—¶çš„æœ€å¤§åˆ©æ¶¦
        dp[0] = [0, -prices[0]]
        for i in range(1,len(prices)):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
        return dp[len(prices)-1][0]
```

#### 123æœ€å¤šä¸¤æ¬¡äº¤æ˜“,æœ€å¤šä¸€æ”¯è‚¡ç¥¨

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices: return 0
        le = len(prices)
        dp = [[[0 for k in range(2)] for j in range(3)] for i in range(le)]
        # å®šä¹‰dp[i][k][0]ä¸ºç¬¬iå¤©æœ€å¤škæ¬¡äº¤æ˜“æ²¡æœ‰è‚¡ç¥¨æ—¶çš„æœ€å¤§åˆ©æ¶¦
        # å®šä¹‰dp[i][k][1]ä¸ºç¬¬iå¤©æœ€å¤škæ¬¡äº¤æ˜“æœ‰ä¸€æ”¯è‚¡ç¥¨æ—¶çš„æœ€å¤§åˆ©æ¶¦
        dp[0] = [[0, 0], [0, -prices[0]], [0, -prices[0]]]
        for i in range(1,le):
            for k in range(2,0,-1):
                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i])
        return dp[le-1][2][0]
```

#### 188æœ€å¤škæ¬¡äº¤æ˜“,æœ€å¤šä¸€æ”¯è‚¡ç¥¨ğŸ·

```py
```

#### 309ä¸é™äº¤æ˜“äº¤æ˜“,æœ€å¤šä¸€æ”¯è‚¡ç¥¨,å«å†·å†»æœŸğŸ·

```py
```

#### 714ä¸é™äº¤æ˜“äº¤æ˜“,æœ€å¤šä¸€æ”¯è‚¡ç¥¨,å«æ‰‹ç»­è´¹ğŸ·

```py
```

### 300æœ€é•¿ä¸Šå‡å­åºåˆ—

```py
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        
        "è§£æ³•ä¸€"
        # if not nums: return 0
        # le = len(nums)
        # if le == 1:
        #     return 1
        # res = 0
        # dp = [1 for i in range(le)]
        # for i in range(1,le):
        #     for j in range(i):
        #         if nums[j]<nums[i]:
        #             dp[i] = max(dp[i], dp[j]+1)
        #     res = max(res,dp[i])
        # return res
        
        "è§£æ³•äºŒ"
        import bisect
        if not nums: return 0
        res = list()
        for i in range(len(nums)):
            index = bisect.bisect_left(res,nums[i])
            if index == len(res):
                res.append(nums[i])
            else:
                res[index] = nums[i]
        return len(res)
```

### 322é›¶é’±å…‘æ¢

```py
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        le = len(coins)
        # å®šä¹‰dp[i]ä¸ºå‡‘å¤Ÿé‡‘é¢iæ—¶ä½¿ç”¨ç¡¬å¸çš„æœ€å°å€¼
        dp = [(amount+1) for i in range(amount+1)]
        dp[0] = 0
        for i in range(1,amount+1):
            for j in range(le):
                if coins[j]<=i:
                    dp[i] = min(dp[i], dp[i-coins[j]]+1)
        return -1 if dp[amount]>amount else dp[amount]
```

### 72ç¼–è¾‘è·ç¦»

```py
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        # å®šä¹‰dp[i][j]ä¸ºç”±word1å‰iä¸ªå­—ç¬¦è½¬æ¢ä¸ºword2å‰jä¸ªå­—ç¬¦æ‰€éœ€è¦çš„æœ€å°‘æ“ä½œæ•°
        dp = [[0 for i in range(n+1)] for j in range(m+1)]
        for i in range(m+1):
            dp[i][0] = i
        for j in range(n+1):
            dp[0][j] = j
        for i in range(1,m+1):
            for j in range(1,n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1
        return dp[m][n]
```

## 15å¹¶æŸ¥é›†(Union&Find)

1. å¹¶æŸ¥é›†(union&find)æ˜¯ä¸€ç§æ ‘å½¢æ•°æ®ç»“æ„,ç”¨äºå¤„ç†ä¸€äº›ä¸äº¤é›†(Disjoint Sets)çš„åˆå¹¶å’ŒæŸ¥è¯¢é—®é¢˜
2. find:ç¡®å®šå…ƒç´ å±äºå“ªä¸€ä¸ªå­é›†,å®ƒå¯ä»¥è¢«ç”¨æ¥ç¡®å®šä¸¤ä¸ªå…ƒç´ æ˜¯å¦å±äºåŒä¸€å­é›†
3. union:å°†ä¸¤ä¸ªå­é›†åˆå¹¶æˆåŒä¸€ä¸ªé›†åˆ
4. å¹¶æŸ¥é›†ä¼˜åŒ–
   1. åˆå¹¶æ—¶å‚è€ƒrank,å°†rankå°çš„é›†åˆåˆå¹¶åˆ°rankå¤§çš„é›†åˆä¸­,å‡å°‘åˆå¹¶åçš„rankæ•°
   2. æŸ¥æ‰¾æ—¶è¿›è¡Œè·¯å¾„å‹ç¼©,å°†å­èŠ‚ç‚¹å…¨éƒ¨æŒ‡å‘rootèŠ‚ç‚¹,å»æ‰ä¸­é—´å±‚.
   3. ä½¿ç”¨ç¬¬äºŒç§ä¼˜åŒ–å,ä¸éœ€è¦å†è€ƒè™‘ç¬¬ä¸€ç§ä¼˜åŒ–

### 200å²›å±¿æ•°é‡

### 



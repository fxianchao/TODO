# 算法

## 1数组&链表

### 206反转链表

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

"""
# 解法一

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 使用两个指针迭代
        pre = None
        cur = head
        
        while cur:
            nextTemp = cur.next
            cur.next = pre
            pre = cur
            cur = nextTemp
        
        return pre

"""


# 解法二

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 使用两个指针迭代
        pre = None
        cur = head
        
        while cur:
            # 利用python循环赋值特性,去掉中间变量
            pre, cur.next, cur = cur, pre, cur.next
    
        return pre
```

### 24两两交换链表中的节点

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        pre, pre.next = self, head
        
        while pre.next and pre.next.next:
            # cur = pre.next
            # n = cur.next
            # nn = n.next
            # pre.next = n
            # n.next = cur
            # cur.next = nn
            # pre = cur
            
            cur = pre.next
            n = cur.next
            pre.next, n.next, cur.next = n, cur, n.next
            pre = cur
            
        return self.next
```

### 141环形链表

```py
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

"解法一"

# class Solution(object):
#     def hasCycle(self, head):
#         """
#         :type head: ListNode
#         :rtype: bool
#         """
#         fast = slow = head
        
#         while slow and fast and fast.next:
#             slow = slow.next
#             fast = fast.next.next
#             if slow is fast:
#                 return True
        
#         return False
    

"解法二"

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        s = set()
        while head:
            if head in s:
                return True
            s.add(head)
            head = head.next
        
        return False
```

## 2堆栈&队列

### 20有效的括号

```py
class Solution:
    def isValid(self, s: str) -> bool:
        stack = list()
        items = {"}":"{", "]":"[", ")":"("}
        for c in s:
            if c not in items:
                stack.append(c)
            elif not stack:
                return False
            elif items.get(c, None) != stack.pop():
                return False
        return not stack
```

### 232用栈实现队列

```py
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = list()
        self.s2 = list()
        

    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.s1.append(x)
        

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        if not self.s2:
            for i in range(len(self.s1)):
                self.s2.append(self.s1.pop())
        return self.s2.pop()
        
        
    def peek(self) -> int:
        """
        Get the front element.
        """
        if not self.s2:
            for i in range(len(self.s1)):
                self.s2.append(self.s1.pop())
        return self.s2[-1]
        

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return not(self.s1 or self.s2)
        


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```

### 225用队列实现栈

```py
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = list()
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue.append(x)
        

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue.pop()
        

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[-1]
        
        
    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue
        


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
```

### 703数据流中的第K大元素

```py
"解法一"

# from queue import PriorityQueue as pq
# class KthLargest:

#     def __init__(self, k: int, nums: List[int]):
#         self.pq = pq()
#         self.k = k
#         for i in nums:
#             self.pq.put(i)
#             if (self.pq.qsize())>k:
#                 self.pq.get()
        

#     def add(self, val: int) -> int:
#         self.pq.put(val);
#         if (self.pq.qsize())>self.k:
#             self.pq.get()
#         ret = self.pq.get()
#         self.pq.put(ret)
#         return ret

"解法二"

import heapq
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        heapq.heapify(nums)
        self.hp = nums
        self.k = k
        while len(self.hp)>k:
            heapq.heappop(self.hp)
        

    def add(self, val: int) -> int:
        if len(self.hp)<self.k:
            heapq.heappush(self.hp,val)
        elif self.hp[0]<val:
            heapq.heapreplace(self.hp,val)
        return self.hp[0]


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
```

### 239滑动窗口最大值

```py
import heapq
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if not nums or k == 1:
            return nums
        
        """
        "解法一"
        return [max(nums[i:i+k]) for i in range(len(nums)-k+1)]
        """
        
        """
        "解法二"
        buf = list()
        ma = list()
        for i in range(len(nums)):
            if i<k:
                heapq.heappush(buf,nums[i])
                if i==k-1:
                    ma.append(heapq.nlargest(1,buf)[0])
                else:
                    pass
            else:
                buf.remove(nums[i-k])
                heapq.heappush(buf,nums[i])
                ma.append(heapq.nlargest(1,buf)[0])
        
        return ma
        
        """
        
        
        "解法三"
        ma = list()
        dq = deque()
        for i in range(len(nums)):
            # 新到的元素比队列尾部元素大则剔除队列尾部元素
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()
            # 添加新元素时保存数组下标,避免数组中存在重复元素时无法获取元素下标
            dq.append(i)
            # 当队首元素超出窗口范围时移除队首元素
            if dq[0] == i-k:
                dq.popleft()
            # 从窗口被填满开始,记录队首元素即窗口中最大值
            if i >= k-1:
                ma.append(nums[dq[0]])

        return ma
```

## 3映射&集合

### 242有效的字母异位词

```py
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
        # "解法一"
        # return sorted(s) == sorted(t)

       
        # "解法二"
        # dict1 = dict()
        # dict2 = dict()
        # for c in s:
        #     dict1[c] = dict1.get(c,0) + 1
        # for c in t:
        #     dict2[c] = dict2.get(c,0) + 1
        # return dict1 == dict2
        
        "解法三"
        ls = [0]*26
        for c in s:
            ls[ord(c)-ord('a')] += 1
        for c in t:
            ls[ord(c)-ord('a')] -= 1
        
        return [_ for _ in ls if _ != 0] == []
```

### 1两数之和

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        # "解法一"
        # for i in range(len(nums)-1):
        #     for j in range(i+1,len(nums)):
        #         if nums[i]+nums[j] == target:
        #             return [i,j]

        "解法二"
        dic = dict()
        for i in range(len(nums)):
            j = dic.get(target - nums[i], None)
            if j is not None and j != i:
                return [j,i]
            dic[nums[i]] = i
```

### 15 三数之和

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if len(nums)<3:
            return []

        res = set()
        nums.sort()
        
        "解法一"
        # for i in range(len(nums)-2):
        #     for j in range(i+1,len(nums)-1):
        #         for k in range(j+1,len(nums)):
        #             if nums[i]+nums[j]+nums[k] == 0:
        #                 res.add((nums[i],nums[j],nums[k]))
        # return res
        
        "解法二"
        # for i, v in enumerate(nums[:-2]):
        #     if i >= 1 and nums[i] == nums[i-1]:
        #         continue
        #     d = dict()
        #     for x in nums[i+1:]:
        #         if x not in d:
        #             d[-v-x] = 1
        #         else:
        #             res.add((v,-v-x,x))
        # return res 
        
        "解法三"
        for i, v in enumerate(nums[:-2]):
            if i >= 1 and nums[i] == nums[i-1]:
                continue
            l = i+1
            r = len(nums)-1
            while l<r:
                su = v + nums[l] + nums[r]
                if su > 0:
                    r -= 1
                elif su < 0:
                    l += 1
                else:
                    res.add((v,nums[l],nums[r]))
                    while l < r and nums[l] == nums[l+1]:
                        l += 1
                    while l < r and nums[r] == nums[r-1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res
```

### 

# 算法

## 1数组(Array)&链表(Linked List)

1. 数组:支持随机访问,但是插入和删除复杂
2. 链表:插入和删除方便,但是不支持随机访问

### 206反转链表

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

"""
# 解法一

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 使用两个指针迭代
        pre = None
        cur = head
        
        while cur:
            nextTemp = cur.next
            cur.next = pre
            pre = cur
            cur = nextTemp
        
        return pre

"""


# 解法二

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 使用两个指针迭代
        pre = None
        cur = head
        
        while cur:
            # 利用python循环赋值特性,去掉中间变量
            pre, cur.next, cur = cur, pre, cur.next
    
        return pre
```

### 24两两交换链表中的节点

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        pre, pre.next = self, head
        
        while pre.next and pre.next.next:
            # cur = pre.next
            # n = cur.next
            # nn = n.next
            # pre.next = n
            # n.next = cur
            # cur.next = nn
            # pre = cur
            
            cur = pre.next
            n = cur.next
            pre.next, n.next, cur.next = n, cur, n.next
            pre = cur
            
        return self.next
```

### 141环形链表

```py
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

"解法一"

# class Solution(object):
#     def hasCycle(self, head):
#         """
#         :type head: ListNode
#         :rtype: bool
#         """
#         fast = slow = head
        
#         while slow and fast and fast.next:
#             slow = slow.next
#             fast = fast.next.next
#             if slow is fast:
#                 return True
        
#         return False
    

"解法二"

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        s = set()
        while head:
            if head in s:
                return True
            s.add(head)
            head = head.next
        
        return False
```

## 2堆栈(Stack)&队列(Queue)

1. 栈:先入后出
2. 队列:先入先出
3. 优先队列(PriorityQueue):正常入,按照优先级出
   1. 实现机制
      1. 堆(二叉堆,多项式堆,斐波那契堆),根节点大于(小于)左右节点
      2. 二叉搜索树

### 20有效的括号

```py
class Solution:
    def isValid(self, s: str) -> bool:
        stack = list()
        items = {"}":"{", "]":"[", ")":"("}
        for c in s:
            if c not in items:
                stack.append(c)
            elif not stack:
                return False
            elif items.get(c, None) != stack.pop():
                return False
        return not stack
```

### 232用栈实现队列

```py
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = list()
        self.s2 = list()
        

    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.s1.append(x)
        

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        if not self.s2:
            for i in range(len(self.s1)):
                self.s2.append(self.s1.pop())
        return self.s2.pop()
        
        
    def peek(self) -> int:
        """
        Get the front element.
        """
        if not self.s2:
            for i in range(len(self.s1)):
                self.s2.append(self.s1.pop())
        return self.s2[-1]
        

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return not(self.s1 or self.s2)
        


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```

### 225用队列实现栈

```py
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = list()
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue.append(x)
        

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue.pop()
        

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[-1]
        
        
    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue
        


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
```

### 703数据流中的第K大元素

```py
"解法一"

# from queue import PriorityQueue as pq
# class KthLargest:

#     def __init__(self, k: int, nums: List[int]):
#         self.pq = pq()
#         self.k = k
#         for i in nums:
#             self.pq.put(i)
#             if (self.pq.qsize())>k:
#                 self.pq.get()
        

#     def add(self, val: int) -> int:
#         self.pq.put(val);
#         if (self.pq.qsize())>self.k:
#             self.pq.get()
#         ret = self.pq.get()
#         self.pq.put(ret)
#         return ret

"解法二"

import heapq
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        heapq.heapify(nums)
        self.hp = nums
        self.k = k
        while len(self.hp)>k:
            heapq.heappop(self.hp)
        

    def add(self, val: int) -> int:
        if len(self.hp)<self.k:
            heapq.heappush(self.hp,val)
        elif self.hp[0]<val:
            heapq.heapreplace(self.hp,val)
        return self.hp[0]


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
```

### 239滑动窗口最大值

```py
import heapq
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if not nums or k == 1:
            return nums
        
        """
        "解法一"
        return [max(nums[i:i+k]) for i in range(len(nums)-k+1)]
        """
        
        """
        "解法二"
        buf = list()
        ma = list()
        for i in range(len(nums)):
            if i<k:
                heapq.heappush(buf,nums[i])
                if i==k-1:
                    ma.append(heapq.nlargest(1,buf)[0])
                else:
                    pass
            else:
                buf.remove(nums[i-k])
                heapq.heappush(buf,nums[i])
                ma.append(heapq.nlargest(1,buf)[0])
        
        return ma
        
        """
        
        
        "解法三"
        ma = list()
        dq = deque()
        for i in range(len(nums)):
            # 新到的元素比队列尾部元素大则剔除队列尾部元素
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()
            # 添加新元素时保存数组下标,避免数组中存在重复元素时无法获取元素下标
            dq.append(i)
            # 当队首元素超出窗口范围时移除队首元素
            if dq[0] == i-k:
                dq.popleft()
            # 从窗口被填满开始,记录队首元素即窗口中最大值
            if i >= k-1:
                ma.append(nums[dq[0]])

        return ma
```

## 3映射(Map)&集合(Set)

1. 哈希函数
2. 哈希碰撞:链表解决
3. 哈希和二叉搜索树实现映射和集合
4. 映射:键值对
5. 集合:键和值相同

### 242有效的字母异位词

```py
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
        # "解法一"
        # return sorted(s) == sorted(t)

       
        # "解法二"
        # dict1 = dict()
        # dict2 = dict()
        # for c in s:
        #     dict1[c] = dict1.get(c,0) + 1
        # for c in t:
        #     dict2[c] = dict2.get(c,0) + 1
        # return dict1 == dict2
        
        "解法三"
        ls = [0]*26
        for c in s:
            ls[ord(c)-ord('a')] += 1
        for c in t:
            ls[ord(c)-ord('a')] -= 1
        
        return [_ for _ in ls if _ != 0] == []
```

### 1两数之和

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        # "解法一"
        # for i in range(len(nums)-1):
        #     for j in range(i+1,len(nums)):
        #         if nums[i]+nums[j] == target:
        #             return [i,j]

        "解法二"
        dic = dict()
        for i in range(len(nums)):
            j = dic.get(target - nums[i], None)
            if j is not None:
                return [j,i]
            dic[nums[i]] = i
```

### 15 三数之和

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if len(nums)<3:
            return []

        res = set()
        nums.sort()
        
        "解法一"
        # for i in range(len(nums)-2):
        #     for j in range(i+1,len(nums)-1):
        #         for k in range(j+1,len(nums)):
        #             if nums[i]+nums[j]+nums[k] == 0:
        #                 res.add((nums[i],nums[j],nums[k]))
        # return res
        
        "解法二"
        # for i, v in enumerate(nums[:-2]):
        #     if i >= 1 and nums[i] == nums[i-1]:
        #         continue
        #     d = dict()
        #     for x in nums[i+1:]:
        #         if x not in d:
        #             d[-v-x] = 1
        #         else:
        #             res.add((v,-v-x,x))
        # return res 
        
        "解法三"
        for i, v in enumerate(nums[:-2]):
            if i >= 1 and nums[i] == nums[i-1]:
                continue
            l = i+1
            r = len(nums)-1
            while l<r:
                su = v + nums[l] + nums[r]
                if su > 0:
                    r -= 1
                elif su < 0:
                    l += 1
                else:
                    res.add((v,nums[l],nums[r]))
                    while l < r and nums[l] == nums[l+1]:
                        l += 1
                    while l < r and nums[r] == nums[r-1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res
```

## 4树(Tree)&二叉树(Binary Tree)&二叉搜索树(Binary Search Tree)

1. 链表结构中添加一个next指针,得到一棵二叉树
2. 二叉搜索树(Binary Search Tree),也称有序二叉树(Ordered Binary Tree)或排序二叉树(Sorted Binary Tree),指一棵`空树`或者满足以下条件的二叉树:
   1. `左子树`上所有结点的值均小于它的根结点的值
   2. `右子树`上所有结点的值均大于它的根结点的值
   3. 递归的(Recursively),左右子树也分别为二叉查找树

### 98验证二叉搜索树

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# "解法一"
# class Solution:
#     def isValidBST(self, root: TreeNode) -> bool:
#         def inorder(root):
#             if root is None:
#                 return []
#             return inorder(root.left) + [root.val] + inorder(root.right)
            
#         order = inorder(root)
#         return order == sorted(set(order))
        

# "解法二"
# class Solution:
#     def isValidBST(self, root: TreeNode) -> bool:
#         self.pre = None
#         def isBST(node):
#             if node is None:
#                 return True
#             if not isBST(node.left):
#                 return False
#             if self.pre and self.pre.val >= node.val:
#                 return False
#             self.pre = node
#             return isBST(node.right)
#         return isBST(root)
        

# "解法三"
# class Solution:
#     def isValidBST(self, root: TreeNode) -> bool:
#         stack = [(root,float("-inf"),float("inf")),]
#         while stack:
#             r,mi,ma = stack.pop()
#             if r is None:
#                 continue
#             if r.val>=ma or r.val<=mi:
#                 return False
#             stack.append((r.left,mi,r.val))
#             stack.append((r.right,r.val,ma))
#         return True
            

"解法四"
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def isBST(r,mi,ma):
            if r is None:
                return True
            if r.val>=ma or r.val<=mi:
                return False
            return isBST(r.left,mi,r.val) and isBST(r.right,r.val,ma)
        return isBST(root,float("-inf"),float("inf"))

```

### 236二叉树的最近公共祖先

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        "解法一"
        # if root is None or root is p or root is q:
        #     return root
        # left = self.lowestCommonAncestor(root.left,p,q)
        # right = self.lowestCommonAncestor(root.right,p,q)
        # if left:
        #     if right:
        #         return root
        #     return left
        # return right
        
        
        "解法二"
        stack = [root]
        parent_map = {root:None}
        while p not in parent_map or q not in parent_map:
            cur = stack.pop()
            if cur.left:
                parent_map[cur.left] = cur
                stack.append(cur.left)
            if cur.right:
                parent_map[cur.right] = cur
                stack.append(cur.right)
        ancestor = set()
        while p:
            ancestor.add(p)
            p = parent_map[p]
        while q not in ancestor:
            q = parent_map[q]
        return q
```

### 235二叉搜索树的最近公共祖先

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        "解法一"
        # if root is None or root is p or root is q:
        #     return root
        # left = self.lowestCommonAncestor(root.left,p,q)
        # right = self.lowestCommonAncestor(root.right,p,q)
        # if left:
        #     if right:
        #         return root
        #     return left
        # return right
        
        "解法二"
        # if root is None:
        #     return root
        # if root.val < p.val and root.val < q.val:
        #     return self.lowestCommonAncestor(root.right,p,q)
        # if root.val > p.val and root.val > q.val:
        #     return self.lowestCommonAncestor(root.left,p,q)
        # return root
        
        
        "解法三"
        # while root:
        #     if root.val < p.val and root.val < q.val:
        #         root = root.right
        #     elif root.val > p.val and root.val > q.val:
        #         root = root.left
        #     else:
        #         return root
        
        "解法四"
        while (p.val-root.val)*(q.val-root.val) > 0:
            root = (root.left,root.right)[p.val>root.val]
        return root
```

## 5二叉树遍历(Binary Tree Travesal)

1. 深度优先搜索中(DFS),根据根节点,左右节点的相对顺序分为
   1. 前序(Pre-order):根-左-右
   2. 中序(In-order):左-根-右
   3. 后序(Post-order):左-右-根

### 144二叉树的前序遍历

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        "解法一"
        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
    
        "解法二"
        # stack = [root]
        # out = list()
        # while stack:
        #     node = stack.pop()
        #     if node is not None:
        #         out.append(node.val)
        #     if node.right is not None:
        #         stack.append(node.right)
        #     if node.left is not None:
        #         stack.append(node.left)
        # return out
    
        "解法三"
        out = list()
        def preorder(root):
            if root:
                out.append(root.val)
                preorder(root.left)
                preorder(root.right)
        preorder(root)
        return out
```

### 94二叉树的中序遍历

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if root is None:
            return []
        
        "解法一"
        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)
        
        "解法二"
        stack, out, node = [], [], root
        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            node = stack.pop()
            out.append(node.val)
            node = node.right
        return out
            
        "解法三"
        # out = list()
        # def inorder(root):
        #     if root:
        #         inorder(root.left)
        #         out.append(root.val)
        #         inorder(root.right)
        # inorder(root)
        # return out
```

### 145二叉树的后序遍历

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        
        "解法一"
        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val] if root else []

        
        "解法二"
        # out = list()
        # def hostorder(root):
        #     if root:
        #         hostorder(root.left)
        #         hostorder(root.right)
        #         out.append(root.val)
        # hostorder(root)
        # return out
        
        "解法三"
        if not root:
            return []
        stack, out = [root], []
        while stack:
            node = stack.pop()
            if node is not None:
                out.append(node.val)
            if node.left is not None:
                stack.append(node.left)
            if node.right is not None:
                stack.append(node.right)
        return out[::-1]
```

## 6递归(Recursion)&分治(Divide&Conquer)

1. 递归:终止条件,递推公式
2. 分治:终止条件,划分,处理,合并

### 50Pow(x,n)

```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        
        "解法一"
        # return x**n
    
    
        "解法二:超时"
        # if n < 0:
        #     x, n = 1/x, -n
        # res = 1
        # for i in range(n):
        #     res *= x
        # return res
      
    
        "解法三"
        # if n == 0:
        #     return 1
        # if n < 0:
        #     return 1 / self.myPow(x,-n)
        # if n%2:
        #     return x*self.myPow(x,n-1)
        #    # return x*self.myPow(x*x,n//2)
        # return self.myPow(x*x,n//2)
        
        
        "解法四"
        if n < 0:
            x, n = 1/x, -n
        pow = 1
        while n:
            if n&1:
                pow *= x  # 相当于n%2==1时,x*self.myPow(x,n-1)
            x *= x
            n >>= 1
        return pow
```

### 169求众数

```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        
        "解法一"
        # for i in set(nums):
        #     # if nums.count(i) > len(nums)//2:
        #     count = sum(1 for j in nums if j == i)
        #     if count > len(nums)//2:
        #         return i
        
        "解法二"
        # dic = dict()
        # for i in nums:
        #     if i not in dic:
        #         dic[i] = 1
        #     else:
        #         dic[i] += 1
        # for i, v in dic.items():
        #     if v > len(nums)//2:
        #         return i
        # # return max(dic.keys(),key=dic.get)  # 字典根据值取键
        
        # counter = collections.Counter(nums)  # 借助计数器
        # return counter.most_common(1)[0][0]
        
        "解法三"
        # nums.sort()
        # # return nums[len(nums)//2]
        # pre = None
        # cnt = 1
        # for i in nums:
        #     if i == pre:
        #         cnt += 1
        #     else:
        #         pre = i
        #         cnt = 1
        #     if cnt > len(nums)//2:
        #         return i
        
        "解法四"
        # def majority(lo, hi):
        #     if lo == hi:
        #         return nums[lo]
        #     mid = lo + (hi-lo)//2
        #     left = majority(lo,mid)
        #     right = majority(mid+1,hi)
        #     if left == right:
        #         return left
        #     left_cnt = nums[lo:hi+1].count(left)
        #     right_cnt = nums[lo:hi+1].count(right)
        #     return left if left_cnt > right_cnt else right
        # return majority(0,len(nums)-1)
        
        "解法五"
        # while True:
        #     rand = random.choice(nums)
        #     if nums.count(rand) > len(nums)//2:
        #         return rand
        
        "解法六"
        # cnt = 0
        # candidate = None
        # for i in nums:
        #     if cnt == 0:
        #         candidate = i
        #         cnt += 1
        #     else:
        #         cnt += (1 if candidate == i else -1)
        # return candidate
        
        cnt = 0
        candidate = None
        for i in nums:
            if cnt == 0:
                candidate = i
            cnt += (1 if i == candidate else -1)
        return candidate
```

## 7贪心算法(Greedy)

1. 在对问题求解时,总是做出在当前看来是最好的选择
2. 适用场景:问题能够分解成子问题来解决,子问题的最优解能递推到最终问题的最优解.这种子问题最优解称为`最优子结构`
3. 贪心算法和动态规划的不同:贪心算法对每个子问题都做出选择,`不能回退`.而动态规划会保存以前的运算结果,并根据以前的结果对当前进行选择,`有回退功能`

### 122买卖股票的最佳时机II

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(len(prices)-1):
            cha = prices[i+1]-prices[i]
            if cha > 0:
                profit += cha
        return profit
```

## 8广度优先搜索(BFS,Bready-First-Search)

1. 不需要递归,使用队列实现

```py
def BFS(graph,start,end):
    queue = list()  # 使用列表模拟队列
    queue.append(start)
    visited = set()  # 使用集合保存已访问的元素,树中不需要保存

    while queue:
        node = queue.pop(0)  # 弹出队首元素
        process(node)
        visited.add(node)

        nodes = generate_related_nodes(node)  # 当前节点的下一层节点,在图中需判断节点是否被访问过
        queue.append(nodes)
    other_processing_work()
```

### 102二叉树的层次遍历

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []
        
        "解法一"
        # queue = collections.deque()
        # queue.append(root)
        # res = list()
        # # vistted = set()
        # while queue:
        #     le = len(queue)
        #     current_level = list()
        #     for _ in range(le):
        #         node = queue.popleft()
        #         current_level.append(node.val)
        #         if node.left:
        #             queue.append(node.left)
        #         if node.right:
        #             queue.append(node.right)
        #     res.append(current_level)
        # return res
        
        "解法二"
        res = list()
        def _DFS(node,level):
            if not node:
                return
            if len(res) < level + 1:
                res.append([])
            res[level].append(node.val)
            _DFS(node.left,level + 1)
            _DFS(node.right,level + 1)
        _DFS(root,0)
        return res
```

### 104二叉树的最大深度

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        "解法一"
        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
    
        "解法二"
        # queue = collections.deque()
        # queue.append(root)
        # ma = 0
        # while queue:
        #     le = len(queue)
        #     for i in range(le):
        #         node = queue.popleft()
        #         if node.left:queue.append(node.left)
        #         if node.right:queue.append(node.right)
        #     ma += 1
        # return ma
        
        "解法三"
        self.ma = 0
        def DFS(node,level):
            if node is None:
                return
            self.ma = max(self.ma,level+1)
            DFS(node.left,level+1)
            DFS(node.right,level+1)
        DFS(root,0)
        return self.ma
```

### 111二叉树的最小深度

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        
        "解法一"
        # if root is None:
        #     return 0
        # if root.left is None:
        #     return 1 + self.minDepth(root.right)
        # if root.right is None:
        #     return 1 + self.minDepth(root.left)
        # return 1 + min(self.minDepth(root.right), self.minDepth(root.left))
        
        "解法二"
        # if root is None:
        #     return 0
        # queue = collections.deque()
        # queue.append(root)
        # mi = 0
        # while queue:
        #     le = len(queue)
        #     for _ in range(le):
        #         node = queue.popleft()
        #         if node.left is None and node.right is None:
        #             return mi + 1
        #         if node.left: queue.append(node.left)
        #         if node.right:queue.append(node.right)
        #     mi += 1
        
        "解法三"
        if root is None:
            return 0
        self.mi = float("inf")
        def DFS(node,level):
            if node is None:
                return
            if node.left is None and node.right is None:
                self.mi = min(self.mi, level + 1)
            DFS(node.left,level+1)
            DFS(node.right,level+1)
        DFS(root,0)
        return self.mi
```

### 22括号生成

```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        
        "解法一"
        # def gen(left, right, st, res):
        #     if left == 0 and right == 0:
        #         res.append(st)
        #         return
        #     if left > 0:
        #         gen(left-1, right, st + "(", res)
        #     if right > left:
        #         gen(left, right - 1, st + ")", res)
        # result = list()
        # gen(n, n, "", result)
        # return result
    
        "解法二"
        if n == 0:
            return [""]
        ans = list()
        for i in range(n):
            for left in self.generateParenthesis(i):
                for right in self.generateParenthesis(n-i-1):
                    ans.append(f"({left}){right}")
        return ans
```

## 9深度优先搜索(DFS,Depth-First-Search)

1. 有递归版本和非递归版本
2. 递归版本代码简单
3. 非递归版本需要借助栈来实现

```py
# 递归版本
visited = set()
def DFS(node, visted):
    process(node)
    visited.add(node)
    for next_node in node.next_nodes():
        if next_node not in visited:
            DFS(next_node, visited)
```

```py
# 非递归版本
def DFS(tree):
    visited, stack = set(), [tree.node]  # 使用列表模拟栈
    while stack:
        node = stack.pop()  # 弹出栈顶元素
        process(node)
        visited.add(node)

        nodes = generate_related_nodes(node)
        stack.append(nodes)
    other_processing_work()
```

## 


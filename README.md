- [1-上位机](#1-上位机)
    - [19-3-20](#19-3-20)
      - [调TCP](#调tcp)
    - [19-3-21](#19-3-21)
      - [TCP发文件](#tcp发文件)
    - [19-3-22](#19-3-22)
      - [展示数据](#展示数据)
    - [19-4-8](#19-4-8)
      - [展示数据优化](#展示数据优化)
      - [TCP连接去掉wait](#tcp连接去掉wait)
    - [19-4-9](#19-4-9)
      - [存数据库](#存数据库)
    - [19-4-10](#19-4-10)
      - [安装pyside2](#安装pyside2)
      - [学习pyside2示例](#学习pyside2示例)
    - [19-4-12](#19-4-12)
      - [折线图初步](#折线图初步)
- [2-云服务器](#2-云服务器)
    - [19-3-13](#19-3-13)
      - [购买](#购买)
    - [19-3-14](#19-3-14)
      - [~~重装~~](#重装)
      - [~~安装pip3~~](#安装pip3)
      - [~~软件升级~~](#软件升级)
      - [~~创建python3虚拟环境'flask_p3'~~](#创建python3虚拟环境flask_p3)
    - [19-3-15](#19-3-15)
      - [~~快速激活虚拟环境~~](#快速激活虚拟环境)
      - [~~安装pip~~](#安装pip)
      - [~~安装flask(主)~~](#安装flask主)
    - [19-3-23](#19-3-23)
      - [~~删除虚拟环境`flask_p3`~~](#删除虚拟环境flask_p3)
      - [~~软件升级~~](#软件升级-1)
      - [~~新建虚拟环境`flask_p3`~~](#新建虚拟环境flask_p3)
      - [~~安装nginx~~](#安装nginx)
    - [19-3-25](#19-3-25)
      - [重装](#重装)
      - [软件升级](#软件升级)
      - [安装pip3](#安装pip3)
      - [安装venv](#安装venv)
      - [新建虚拟环境`flask_p3`](#新建虚拟环境flask_p3)
      - [修改`.bashrc`简化命令](#修改bashrc简化命令)
      - [安装配置nginx](#安装配置nginx)
    - [19-3-26](#19-3-26)
      - [配置微信公众号服务器](#配置微信公众号服务器)
        - [nginx虚拟主机配置](#nginx虚拟主机配置)
        - [flask后台](#flask后台)
        - [微信公众号配置(测试号)](#微信公众号配置测试号)
    - [19-3-27](#19-3-27)
      - [切换用户](#切换用户)
      - [查看当前登录用户](#查看当前登录用户)
    - [19-3-30](#19-3-30)
      - [软件更新](#软件更新)
      - [内核](#内核)
      - [配置vim](#配置vim)
      - [终端配色](#终端配色)
      - [mysql客户端](#mysql客户端)
      - [踢除用户](#踢除用户)
    - [19-4-13](#19-4-13)
      - [软件升级](#软件升级-1)
- [3-程序员面试宝典](#3-程序员面试宝典)
  - [19-3-28](#19-3-28)
    - [第一部分 求职过程](#第一部分-求职过程)
      - [第1章 应聘求职](#第1章-应聘求职)
        - [渠道](#渠道)
        - [流程](#流程)
      - [第2章 简历书写](#第2章-简历书写)
        - [简历注意事项](#简历注意事项)
        - [简历模板](#简历模板)
      - [第3章 求职五部曲](#第3章-求职五部曲)
        - [笔试](#笔试)
        - [电话面试](#电话面试)
        - [面试](#面试)
        - [签约](#签约)
        - [违约](#违约)
      - [第4章 职业生涯发展规划](#第4章-职业生涯发展规划)
        - [缺乏工作经验的应届毕业生](#缺乏工作经验的应届毕业生)
        - [更换工作的程序员](#更换工作的程序员)
        - [快乐的工作](#快乐的工作)
    - [第二部分 C/Cpp程序设计](#第二部分-ccpp程序设计)
      - [第5章 程序设计基本概念](#第5章-程序设计基本概念)
        - [5.1 赋值语句](#51-赋值语句)
        - [5.2 递增语句](#52-递增语句)
        - [5.3 编程风格](#53-编程风格)
        - [5.4 类型转换](#54-类型转换)
        - [5.5 运算符问题](#55-运算符问题)
        - [5.6 a,b交换与比较](#56-ab交换与比较)
        - [5.7 c和c++的关系](#57-c和c的关系)
        - [5.8 程序设计的其他问题](#58-程序设计的其他问题)
  - [19-3-29](#19-3-29)
      - [第6章 预处理,const与sizeof](#第6章-预处理const与sizeof)
        - [6.1 宏定义](#61-宏定义)
        - [6.2 const](#62-const)
  - [19-4-2](#19-4-2)
    - [第6章(续)](#第6章续)
      - [6.3 sizeof](#63-sizeof)
      - [6.4 内联函数和宏定义](#64-内联函数和宏定义)
  - [19-4-4](#19-4-4)
      - [第7章 指针与引用](#第7章-指针与引用)
        - [7.1 指针基本问题](#71-指针基本问题)
        - [7.2 传递动态内存](#72-传递动态内存)
- [4-python官方文档](#4-python官方文档)
  - [~~>>>1入门教程{19-4-1}~~](#1入门教程19-4-1)
    - [19-3-24](#19-3-24)
      - [1课前甜点](#1课前甜点)
      - [2使用python解释器](#2使用python解释器)
        - [调用解释器](#调用解释器)
        - [解释器的运行环境](#解释器的运行环境)
      - [3python的非正式介绍](#3python的非正式介绍)
        - [作为计算器使用](#作为计算器使用)
        - [走向编程的第一步](#走向编程的第一步)
      - [4其他流程控制工具](#4其他流程控制工具)
        - [if语句](#if语句)
        - [for语句](#for语句)
        - [range()函数](#range函数)
        - [break和continue语句,以及循环中的else子句](#break和continue语句以及循环中的else子句)
        - [pass语句](#pass语句)
        - [定义函数](#定义函数)
        - [函数定义的更多形式](#函数定义的更多形式)
        - [小插曲:编码风格](#小插曲编码风格)
      - [5数据结构](#5数据结构)
        - [列表的更多特性](#列表的更多特性)
        - [列表作为栈使用](#列表作为栈使用)
        - [列表作为队列使用](#列表作为队列使用)
        - [列表推导式](#列表推导式)
        - [嵌套的列表推导式](#嵌套的列表推导式)
        - [del语句](#del语句)
        - [元组和序列](#元组和序列)
        - [集合](#集合)
        - [字典](#字典)
        - [循环的技巧](#循环的技巧)
        - [深入条件控制](#深入条件控制)
        - [序列和其他类型的比较](#序列和其他类型的比较)
      - [6模块](#6模块)
        - [有关模块的更多信息](#有关模块的更多信息)
        - [以脚本的方式执行模块](#以脚本的方式执行模块)
        - [模块搜索路径](#模块搜索路径)
        - ["编译过的"Python文件](#编译过的python文件)
        - [标准模块](#标准模块)
        - [dir()函数](#dir函数)
        - [包](#包)
        - [从包中导入*](#从包中导入)
        - [子包参考](#子包参考)
        - [多个目录中的包](#多个目录中的包)
    - [19-3-25](#19-3-25-1)
      - [7输入输出](#7输入输出)
        - [更漂亮的输出格式](#更漂亮的输出格式)
        - [格式化字符串字面值(f-字符串)](#格式化字符串字面值f-字符串)
        - [字符串的格式化方法](#字符串的格式化方法)
        - [手动格式化字符串](#手动格式化字符串)
        - [旧的字符串格式化方法](#旧的字符串格式化方法)
        - [读写文件](#读写文件)
        - [文件对象的方法](#文件对象的方法)
        - [使用JSON保存结构化数据](#使用json保存结构化数据)
    - [19-3-27](#19-3-27-1)
      - [8错误和异常](#8错误和异常)
        - [语法错误(解析错误)](#语法错误解析错误)
        - [异常](#异常)
        - [处理异常](#处理异常)
        - [抛出异常](#抛出异常)
        - [用户自定义异常](#用户自定义异常)
        - [定义清理操作](#定义清理操作)
        - [预定义的清理操作](#预定义的清理操作)
    - [19-3-28](#19-3-28-1)
      - [9类](#9类)
        - [名称和对象](#名称和对象)
        - [python作用域和命名空间](#python作用域和命名空间)
        - [初探类](#初探类)
        - [类定义语法](#类定义语法)
        - [类对象](#类对象)
        - [实例对象](#实例对象)
        - [方法对象](#方法对象)
        - [类变量和实例变量](#类变量和实例变量)
        - [补充说明](#补充说明)
        - [继承](#继承)
        - [多重继承](#多重继承)
        - [私有变量](#私有变量)
        - [杂项说明](#杂项说明)
        - [迭代器](#迭代器)
        - [生成器](#生成器)
        - [生成器表达式](#生成器表达式)
    - [19-4-1](#19-4-1)
      - [10标准库简介一](#10标准库简介一)
        - [操作系统接口](#操作系统接口)
        - [文件通配符](#文件通配符)
        - [命令行参数](#命令行参数)
        - [错误输出重定向和程序终止](#错误输出重定向和程序终止)
        - [字符串模式匹配](#字符串模式匹配)
        - [数学](#数学)
        - [互联网访问](#互联网访问)
        - [日期和时间](#日期和时间)
        - [数据压缩](#数据压缩)
        - [性能测量](#性能测量)
        - [质量控制](#质量控制)
        - [包含电池](#包含电池)
      - [11标准库简介二](#11标准库简介二)
        - [格式化输出](#格式化输出)
        - [模板](#模板)
        - [使用二进制数据记录格式](#使用二进制数据记录格式)
        - [多线程](#多线程)
        - [日志](#日志)
        - [弱引用](#弱引用)
        - [用于操作列表的工具](#用于操作列表的工具)
        - [十进制浮点运算](#十进制浮点运算)
      - [12虚拟环境和包](#12虚拟环境和包)
        - [创建虚拟环境](#创建虚拟环境)
        - [使用pip管理包](#使用pip管理包)
      - [13接下来](#13接下来)
      - [14交互式编辑和编辑历史](#14交互式编辑和编辑历史)
        - [TAB补全和编辑历史](#tab补全和编辑历史)
        - [默认交互式解释器的替代品](#默认交互式解释器的替代品)
      - [15浮点算术:争议和限制](#15浮点算术争议和限制)
        - [表示性错误](#表示性错误)
      - [16附录](#16附录)
        - [交互模式](#交互模式)
  - [>>>2Python语言参考](#2python语言参考)
    - [19-4-6](#19-4-6)
      - [1概述](#1概述)
        - [其他实现](#其他实现)
        - [标注](#标注)
- [5-黑马python](#5-黑马python)
  - [~~>>>15-flask教程{19-3-21}~~](#15-flask教程19-3-21)
      - [路由模块](#路由模块)
      - [模板引擎](#模板引擎)
      - [操作数据库](#操作数据库)
      - [表单](#表单)
      - [扩展命令行](#扩展命令行)
      - [认证用户状态](#认证用户状态)
      - [开发REST API的工具](#开发rest-api的工具)
      - [集成前端Twitter Bootstrap框架](#集成前端twitter-bootstrap框架)
      - [本地化日期和时间](#本地化日期和时间)
      - [反向解析](#反向解析)
      - [JSON数据](#json数据)
    - [19-3-20](#19-3-20-1)
      - [数据库迁移](#数据库迁移)
      - [邮箱扩展](#邮箱扩展)
      - [模块划分,循环引用,蓝图](#模块划分循环引用蓝图)
    - [19-3-21](#19-3-21-1)
      - [单元测试](#单元测试)
      - [部署](#部署)
  - [~~>>>16-微信公众号{19-3-23}~~](#16-微信公众号19-3-23)
    - [19-3-23](#19-3-23-1)
      - [微信公众号服务器配置](#微信公众号服务器配置)
      - [收发消息,事件](#收发消息事件)
      - [微信网页授权](#微信网页授权)
  - [~~>>>17-flask项目-爱家租房{19-4-12}~~](#17-flask项目-爱家租房19-4-12)
    - [19-3-29](#19-3-29-1)
      - [前后端分离](#前后端分离)
      - [项目文件目录结构](#项目文件目录结构)
      - [日志功能](#日志功能)
    - [19-3-30](#19-3-30-1)
      - [数据表设计](#数据表设计)
      - [日志系统bug](#日志系统bug)
      - [数据库迁移](#数据库迁移-1)
    - [19-3-31](#19-3-31)
      - [静态文件接口](#静态文件接口)
      - [csrf防护](#csrf防护)
      - [图片验证码](#图片验证码)
      - [开发流程与接口文档](#开发流程与接口文档)
      - [短信验证](#短信验证)
    - [19-4-3](#19-4-3)
      - [注册](#注册)
        - [参数校验](#参数校验)
        - [密码加密](#密码加密)
        - [property装饰器](#property装饰器)
        - [前端拦截表单提交](#前端拦截表单提交)
        - [前端请求头传递csrf_token](#前端请求头传递csrf_token)
      - [登录](#登录)
        - [限制访问次数](#限制访问次数)
        - [后端检查登录状态接口](#后端检查登录状态接口)
        - [后端登出接口](#后端登出接口)
        - [登录验证装饰器](#登录验证装饰器)
    - [19-4-4](#19-4-4-1)
      - [图片服务](#图片服务)
        - [搭建文件存储系统](#搭建文件存储系统)
        - [第三方服务](#第三方服务)
        - [前端异步提交](#前端异步提交)
      - [城区信息--缓存](#城区信息--缓存)
        - [缓存的同步问题](#缓存的同步问题)
      - [前端模板](#前端模板)
    - [19-4-6](#19-4-6-1)
      - [发布房源](#发布房源)
        - [保存房屋基本信息后端](#保存房屋基本信息后端)
        - [保存房屋图片信息后端](#保存房屋图片信息后端)
        - [保存房屋信息前端](#保存房屋信息前端)
    - [19-4-7](#19-4-7)
      - [celery](#celery)
        - [celery模型](#celery模型)
        - [celery使用](#celery使用)
        - [celery目录结构](#celery目录结构)
        - [celery独立的目录使用](#celery独立的目录使用)
        - [celery接收返回值](#celery接收返回值)
    - [19-4-9](#19-4-9-1)
      - [房屋管理](#房屋管理)
        - [展示我的房源](#展示我的房源)
        - [显示主页数据](#显示主页数据)
        - [房屋详情数据](#房屋详情数据)
    - [19-4-11](#19-4-11)
      - [房屋列表](#房屋列表)
        - [过滤规则](#过滤规则)
        - [缓存处理](#缓存处理)
      - [订单](#订单)
        - [时间处理](#时间处理)
        - [保存订单](#保存订单)
        - [查询订单](#查询订单)
        - [接单/拒单](#接单拒单)
        - [评论](#评论)
      - [订单支付](#订单支付)
        - [支付宝接入流程](#支付宝接入流程)
        - [手机网站支付流程](#手机网站支付流程)
    - [19-4-12](#19-4-12-1)
      - [订单支付(续)](#订单支付续)
        - [支付宝密钥与SDK使用](#支付宝密钥与sdk使用)
        - [支付宝支付后端接口](#支付宝支付后端接口)
        - [获取支付结果修改订单](#获取支付结果修改订单)
      - [项目优化](#项目优化)
        - [csrf_token丢失bug的解决](#csrf_token丢失bug的解决)
        - [数据库优化](#数据库优化)
        - [工作流程](#工作流程)
  - [>>>18-通用爬虫模块](#18-通用爬虫模块)
    - [19-4-14](#19-4-14)
      - [爬虫基本概念](#爬虫基本概念)
        - [课程介绍和概念](#课程介绍和概念)
        - [爬虫的分类](#爬虫的分类)
        - [markdown介绍](#markdown介绍)
        - [robots协议](#robots协议)
        - [HTTP和HTTPS协议](#http和https协议)
        - [浏览器发送HTTP请求的过程](#浏览器发送http请求的过程)
    - [19-4-19](#19-4-19)
      - [爬虫基本概念[续]](#爬虫基本概念续)
        - [URL和HTTP请求格式](#url和http请求格式)
        - [字符串类型](#字符串类型)
      - [requests库](#requests库)
        - [发送请求和获取网页字符串](#发送请求和获取网页字符串)
        - [requests发送带参数的请求](#requests发送带参数的请求)
    - [19-4-20](#19-4-20)
      - [requests库[续]](#requests库续)
        - [贴吧爬虫](#贴吧爬虫)
        - [发送POST请求](#发送post请求)
        - [使用代理](#使用代理)
        - [模拟登录的三种方式](#模拟登录的三种方式)
      - [chrome分析psot和json](#chrome分析psot和json)
        - [寻找post的地址](#寻找post的地址)
        - [寻找js和分析js](#寻找js和分析js)
        - [requests小技巧](#requests小技巧)
- [6-牛客网](#6-牛客网)
    - [19-3-22](#19-3-22-1)
      - [C/C++*50](#cc50)
    - [19-3-25](#19-3-25-2)
      - [C/C++*50](#cc50-1)
    - [19-3-27](#19-3-27-2)
      - [C/C++*50](#cc50-2)
    - [19-3-28](#19-3-28-2)
      - [c/c++*50](#cc50)
    - [19-3-31](#19-3-31-1)
      - [c/c++*50](#cc50-1)
- [~~7-WTFPython{19-4-7}~~](#7-wtfpython19-4-7)
    - [19-3-21](#19-3-21-2)
      - [section-大脑运动](#section-大脑运动)
        - [微妙的字符串驻留](#微妙的字符串驻留)
        - [python字典键覆盖](#python字典键覆盖)
        - [try语句块的return](#try语句块的return)
        - [Python会将相同的内存地址分配给第二个对象](#python会将相同的内存地址分配给第二个对象)
        - [for语句每次都会重新赋值](#for语句每次都会重新赋值)
        - [执行时机差异](#执行时机差异)
        - [is和==,-5~256已经分配](#is和-5256已经分配)
        - [引用相同对象](#引用相同对象)
        - [闭包函数与循环变量绑定](#闭包函数与循环变量绑定)
        - [is not是一个二元运算符](#is-not是一个二元运算符)
        - [以外的逗号](#以外的逗号)
        - [字符串末尾的反斜杠](#字符串末尾的反斜杠)
        - [运算符的优先级会影响表达式的求值顺序](#运算符的优先级会影响表达式的求值顺序)
        - [三引号](#三引号)
        - [不存在的午夜?](#不存在的午夜)
        - [布尔是int的子类](#布尔是int的子类)
        - [类属性和实例属性](#类属性和实例属性)
        - [生成器与list](#生成器与list)
        - [tuple也可以改变](#tuple也可以改变)
        - [try语句块在except子句的末尾清除该异常](#try语句块在except子句的末尾清除该异常)
        - [真与假(python2)](#真与假python2)
        - [原地修改没有返回值](#原地修改没有返回值)
        - [子类](#子类)
        - [python字典键转换](#python字典键转换)
        - [赋值语句表达式列表,循环赋值](#赋值语句表达式列表循环赋值)
    - [19-3-28](#19-3-28-3)
      - [section-外表是靠不住的](#section-外表是靠不住的)
        - [即使外表和英文字母一样,但并不一样](#即使外表和英文字母一样但并不一样)
        - [内存空间被释放后重新分配相同地址](#内存空间被释放后重新分配相同地址)
        - [不要混用制表符和空格](#不要混用制表符和空格)
    - [19-4-7](#19-4-7-1)
      - [section-小心地雷](#section-小心地雷)
        - [不支持迭代字典时修改它，字典自动扩容](#不支持迭代字典时修改它字典自动扩容)
        - [del引用计数减1](#del引用计数减1)
        - [迭代列表时删除元素](#迭代列表时删除元素)
        - [for循环，循环变量泄露](#for循环循环变量泄露)
        - [默认的可变参数只绑定一次](#默认的可变参数只绑定一次)
        - [捕获异常](#捕获异常)
        - [+=与+不同](#与不同)
        - [修改外部作用域变量，global](#修改外部作用域变量global)
        - [链式操作](#链式操作)
        - [类定义中嵌套的作用域忽略类作用域的名称解析](#类定义中嵌套的作用域忽略类作用域的名称解析)
        - [元组的逗号](#元组的逗号)
      - [section-隐藏的宝藏](#section-隐藏的宝藏)
        - [antigravity模块是Python开发人员发布的少数复活节彩蛋之一](#antigravity模块是python开发人员发布的少数复活节彩蛋之一)
        - [python没有goto，goto愚人节彩蛋](#python没有gotogoto愚人节彩蛋)
        - [braces，使用大括号的复活节彩蛋](#braces使用大括号的复活节彩蛋)
        - [！=和<>。愚人节彩蛋](#和愚人节彩蛋)
        - [python之禅，复活节彩蛋](#python之禅复活节彩蛋)
        - [循环，异常中的else子句](#循环异常中的else子句)
        - [无穷大infinity的哈希值是 10⁵ x π](#无穷大infinity的哈希值是-10⁵-x-π)
        - [类内双下划线名称修饰](#类内双下划线名称修饰)
      - [section-杂项](#section-杂项)
        - [+=更快](#更快)
        - [字符串拼接 +/format/%/join](#字符串拼接-formatjoin)
        - [inf和nan，无穷大和非数字](#inf和nan无穷大和非数字)
        - [小知识点](#小知识点)
- [8-电影](#8-电影)
    - [19-3-23](#19-3-23-2)
      - [大黄蜂](#大黄蜂)
    - [19-4-3](#19-4-3-1)
      - [海王](#海王)
    - [19-4-5](#19-4-5)
      - [飞驰人生](#飞驰人生)
      - [神探蒲松龄](#神探蒲松龄)

---

<!-- <a href="#" alt="开始" id="1" style="position:fixed;right:10%;bottom:40%;color:rgba(255,0,0,0.2);font-size:32px;text-decoration:none;">首页</a> -->

## 1-上位机

#### 19-3-20

##### 调TCP

* 调通TCP服务器和客户端,实现同时收发.

#### 19-3-21

##### TCP发文件

* TCP可以加载和发送文件.

#### 19-3-22

##### 展示数据

* 上位机可以展示接收到的数据.

#### 19-4-8

##### 展示数据优化

* 高亮显示更新的内容。

##### TCP连接去掉wait

1. 建立TCP连接时去掉wait等待，GUI主进程不再卡顿；
2. 建立连接后改变按钮状态。

#### 19-4-9

##### 存数据库

1. 设计优化器运行记录数据表;
2. 将运行数据实时存入数据库中.

#### 19-4-10

##### 安装pyside2

* 安装并配置pyside2(5.12.2)+python(3.7.3).

##### 学习pyside2示例

* 亲自运行pyside2自带示例并作简要记录.

#### 19-4-12

##### 折线图初步

* 展示第一个折线图.

---

## 2-云服务器

>腾讯云_北一

#### 19-3-13

##### 购买

* 学生一年128 = 120+8(域名).

#### 19-3-14

##### ~~重装~~

* 重装UbuntuServer(18.04).

##### ~~安装pip3~~

1. ubuntu带python3,没有pip3.
2. 命令`sudo apt-get install python3-pip`.

##### ~~软件升级~~

* 命令`sudo apt-get upgrade`.

##### ~~创建python3虚拟环境'flask_p3'~~

* 命令`sudo python3 -m venv /opt/flask_p3`.

#### 19-3-15

##### ~~快速激活虚拟环境~~

1. 在`/usr/bin`下新建文件`flask_p3`,内容为`source /opt/flask_p3/bin/activate`.
2. 在任意目录下使用`source flask_p3`即可激活.
3. 使用`deactivate`退出环境.

##### ~~安装pip~~

1. ubuntu带python2,没有pip.
2. 命令`sudo apt-get install python-pip`.

##### ~~安装flask(主)~~

1. 在虚拟环境`flask_p3`中,安装`flask`时出现权限问题.
2. 因此,使用`sudo`,**安装在python3全局解释器中**.

#### 19-3-23

##### ~~删除虚拟环境`flask_p3`~~

* 直接删除目录`~/opt/flask_p3`.
* 删除快捷方式`/usr/bin/flask_p3`.

##### ~~软件升级~~

* `sudo apt-get upgrade`

##### ~~新建虚拟环境`flask_p3`~~

* 位于`~/env/flask_p3`
* 装包`flask`
* 装包`xmltodict`

##### ~~安装nginx~~

* 命令`sudo apt-get install nginx`.
* 设置为开机启动`sudo systemctl enable nginx`.

#### 19-3-25

##### 重装

* 重装UbuntuServer(18.04).

##### 软件升级

* `sudo apt upgrade`.

##### 安装pip3

* `sudo apt install python3-pip`.

##### 安装venv

* `sudo apt install python3-venv`.

##### 新建虚拟环境`flask_p3`

1. `sudo python3 -m venv .`位于目录`~/env/flask_p3`.
2. 切换到超级用户`sudo su`,否则装包时权限不足.
3. 激活虚拟环境`source /home/ubuntu/env/flask_p3/bin/activate`.
4. 安装包`pip install flask`.
5. 安装包`pip install xmltodict`.
6. 退出环境`deactivate`.

##### 修改`.bashrc`简化命令

```bash
# 激活虚拟环境flask_p3
alias act_flask="source /home/ubuntu/env/flask_p3/bin/activate"
# 清理窗口
alias cl="clear"
# 软件升级
alias upgrade="sudo apt upgrade"
# 更新软件源
alias update="sudo apt update"
```

##### 安装配置nginx

1. `sudo apt install nginx`.
2. 启动服务`sudo systemctl start nginx`.
3. 停止服务`sudo systemctl stop nginx`.
4. 设为开机启动`sudo systemctl enable nginx`.
5. 关闭开机启动`sudo systemctl disable nginx`.
6. 测试服务`sudo nginx -t`.
7. 检测80端口`sudo lsof -i:80`.
8. 配置`/etc/nginx/nginx.config`,已备份原始配置文件.

    ```bash
    ##
    # 高层配置
    ##

    user www-data;  # 用户身份,默认即可.
    worker_processes auto;  # worker_processes定义了nginx对外提供web服务时的worker进程数.最优值取决于许多因素,包括(但不限于)CPU核的数量、存储数据的硬盘数量及负载模式.不能确定的时候,将其设置为可用的CPU内核数将是一个好的开始(设置为“auto”将尝试自动检测它).
    pid /run/nginx.pid;  # NginxPID值保存的文件,默认即可.
    include /etc/nginx/modules-enabled/*.conf;  # 引入模块的各种配置.
    #worker_rlimit_nofile 100000;  # worker_rlimit_nofile更改worker进程的最大打开文件数限制.如果没设置的话,这个值为操作系统的限制.设置后你的操作系统和Nginx可以处理比“ulimit -a”更多的文件,所以把这个值设高,这样nginx就不会有“too many open files”问题了.


    # Events模块,包含nginx中所有处理连接的设置
    events {
      worker_connections 768;  # worker_connections设置可由一个worker进程同时打开的最大连接数.如果设置了上面提到的worker_rlimit_nofile,我们可以将这个值设得很高.记住,最大客户数也由系统的可用socket连接数限制(~64K),所以设置不切实际的高没什么好处.
      multi_accept on;  # multi_accept告诉nginx收到一个新连接通知后接受尽可能多的连接.
      use epoll;  # use设置用于复用客户端线程的轮询方法.如果你使用Linux 2.6+,你应该使用epoll.如果你使用*BSD,你应该使用kqueue.(值得注意的是如果你不知道Nginx该使用哪种轮询方法的话,它会选择一个最适合你操作系统的)
    }


    # HTTP模块,控制着nginx http处理的所有核心特性.因为这里只有很少的配置,所以我们只节选配置的一小部分.所有这些设置都应该在http模块中,甚至你不会特别的注意到这段设置.
    http {

      ##
      # Basic Settings
      ##

      sendfile on;  # sendfile可以让sendfile()发挥作用.sendfile()可以在磁盘和TCP socket之间互相拷贝数据(或任意两个文件描述符).Pre-sendfile是传送数据之前在用户空间申请数据缓冲区.之后用read()将数据从文件拷贝到这个缓冲区,write()将缓冲区数据写入网络.sendfile()是立即将数据从磁盘读到OS缓存.因为这种拷贝是在内核完成的,sendfile()要比组合read()和write()以及打开关闭丢弃缓冲更加有效.
      tcp_nopush on;  # tcp_nopush告诉nginx在一个数据包里发送所有头文件,而不是一个接一个的发送.
      tcp_nodelay on;  # tcp_nodelay告诉nginx不要缓存数据,而是一段一段的发送----当需要及时发送数据时,就应该给应用设置这个属性,这样发送一小块数据信息时就不能立即得到返回值.

      keepalive_timeout 65;  # keepalive_timeout给客户端分配keep-alive链接超时时间.服务器将在这个超时时间过后关闭链接.我们将它设置低些可以让ngnix持续工作的时间更长.
      client_header_timeout 10;  
      client_body_timeout 10;  # client_header_timeout和client_body_timeout设置请求头和请求体(各自)的超时时间.我们也可以把这个设置低些.
      reset_timedout_connection on;  # reset_timeout_connection告诉nginx关闭不响应的客户端连接.这将会释放那个客户端所占有的内存空间.
      send_timeout 10;  # send_timeout指定客户端的响应超时时间.这个设置不会用于整个转发器,而是在两次客户端读取操作之间.如果在这段时间内,客户端没有读取任何数据,nginx就会关闭连接.

      types_hash_max_size 2048;

      server_tokens off;  # server_tokens并不会让nginx执行的速度更快,但它可以关闭在错误页面中的nginx版本数字,这样对于安全性是有好处的.

      # server_names_hash_bucket_size 64;
      # server_name_in_redirect off;

      include /etc/nginx/mime.types;
      default_type application/octet-stream;

      ##
      # SSL Settings
      ##

      ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
      ssl_prefer_server_ciphers on;

      ##
      # Logging Settings
      ##

      # access_log off;
      access_log /var/log/nginx/access.log;  # access_log设置nginx是否将存储访问日志.关闭这个选项可以让读取磁盘IO操作更快(aka,YOLO).
      error_log /var/log/nginx/error.log debug;  # error_log告诉nginx记录什么样的错误:常见的错误日志级别有[debug|info|notice|warn|error|crit|alert|emerg],级别越高记录的信息越少.生产场景一般是warn|error|crit这三个级别之一.


      ##
      # Gzip Settings
      ##

      gzip on;  # gzip是告诉nginx采用gzip压缩的形式发送数据.这将会减少我们发送的数据量
      gzip_vary on;  
      gzip_proxied any;  # gzip_proxied允许或者禁止压缩基于请求和响应的响应流.我们设置为any,意味着将会压缩所有的请求.
      gzip_comp_level 6;  # gzip_comp_level设置数据的压缩等级.这个等级可以是1-9之间的任意数值,9是最慢但是压缩比最大的.我们设置为4,这是一个比较折中的设置.
      gzip_buffers 16 8k;
      gzip_http_version 1.1;
      gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;  # gzip_type设置需要压缩的数据格式.

      # gzip_static on;  # gzip_static告诉nginx在压缩资源之前,先查找是否有预先gzip处理过的资源.这要求你预先压缩你的文件,从而允许你使用最高压缩比,这样nginx就不用再压缩这些文件了.
      # gzip_min_length 1000;  # gzip_min_length设置对数据启用压缩的最少字节数.如果一个请求小于1000字节,我们最好不要压缩它,因为压缩这些小的数据会降低处理此请求的所有进程的速度.
      # gzip_disable "msie6";  # gzip_disable为指定的客户端禁用gzip功能.我们设置成IE6或者更低版本以使我们的方案能够广泛兼容.

      ##
      # Virtual Host Configs
      ##

      # 服务器模块,这些是在不同文件中定义的.如果你的服务器模块不在这些位置,你就得修改这一行来指定正确的位置。
      include /etc/nginx/conf.d/*.conf;
      include /etc/nginx/sites-enabled/*;


      ##
      # else
      ##

      # limit_conn_zone $binary_remote_addr zone=addr:5m;  # limit_conn_zone设置用于保存各种key(比如当前连接数)的共享内存的参数.5m就是5兆字节,这个值应该被设置的足够大以存储(32K*5)32byte状态或者(16K*5)64byte状态.
      # limit_conn addr 100;  # limit_conn为给定的key设置最大连接数.这里key是addr,我们设置的值是100,也就是说我们允许每一个IP地址最多同时打开有100个连接.

      # include /etc/nginx/mime.types;  # include只是一个在当前文件中包含另一个文件内容的指令.这里我们使用它来加载稍后会用到的一系列的MIME类型.
      # default_type text/html;  # default_type设置文件使用的默认的MIME-type.
      # charset UTF-8;  # charset 设置我们的头文件中的默认的字符集.

      # open_file_cache max=100000 inactive=20s;  # open_file_cache打开缓存的同时也指定了缓存最大数目,以及缓存的时间.我们可以设置一个相对高的最大时间,这样我们可以在它们不活动超过20秒后清除掉.
      # open_file_cache_valid 30s;  # open_file_cache_valid在open_file_cache中指定检测正确信息的间隔时间.
      # open_file_cache_min_uses 2;  # open_file_cache_min_uses定义了open_file_cache中指令参数不活动时间期间里最小的文件数.
      # open_file_cache_errors on;  # open_file_cache_errors指定了当搜索一个文件时是否缓存错误信息,也包括再次给配置中添加文件.
    }


    #mail {
    #	# See sample authentication script at:
    #	# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript
    # 
    #	# auth_http localhost/auth.php;
    #	# pop3_capabilities "TOP" "USER";
    #	# imap_capabilities "IMAP4rev1" "UIDPLUS";
    # 
    #	server {
    #		listen     localhost:110;
    #		protocol   pop3;
    #		proxy      on;
    #	}
    # 
    #	server {
    #		listen     localhost:143;
    #		protocol   imap;
    #		proxy      on;
    #	}
    #}
    ```

9. 配置虚拟主机文件
    1. 新建文件`/home/ubuntu/nginx_config/nginx_demo_1`.

        ```bash
        server {
          listen 80;
          server_name 188.131.238.69;
          access_log  /home/ubuntu/nginx_config/logs/nginx_config.log;
          location / {
            index index.html;
            root  /home/ubuntu/project/nginx_demo;
          }
        }
        ```

    2. 建立软连接`sudo ln -s /home/ubuntu/nginx_config/nginx_demo_1  /etc/nginx/sites-enabled/`,应使用完整路径.nginx配置文件会自动读取内容.
    3. 重启nginxf服务`sudo systemctl reload nginx.service`.

#### 19-3-26

##### 配置微信公众号服务器

###### nginx虚拟主机配置

* nginx虚拟主机配置`/home/ubuntu/nginx_config/nginx_demo_1`.

  ```bash
  server {
      listen 80;
      server_name 188.131.238.69;
      access_log  /home/ubuntu/nginx_config/logs/nginx_config.log;

      location / {
      index index.html;
      root  /home/ubuntu/project/nginx_demo;
      }

      location /wechat8000 {
          proxy_pass        http://localhost:8000;
          proxy_set_header  X-Real-IP  $remote_addr;
      }
  }
  ```

###### flask后台

* flask后台配置

  ```py
  # coding:utf-8

  from flask import Flask, request, abort#, render_template
  import hashlib
  import xmltodict
  import time
  #import urllib2
  #import json

  # 常量
  # 微信的token令牌
  WECHAT_TOKEN = "fxianchao521"
  WECHAT_APPID = "wxdced5994bd2d4619"
  WECHAT_APPSECRET = "20cc1947b43272294e8528f26b72861b"

  app = Flask(__name__)


  @app.route("/wechat8000", methods=["GET", "POST"])
  def wechat():
      """对接微信公众号服务器"""
      # 接收微信服务器发送的参数
      signature = request.args.get("signature")
      timestamp = request.args.get("timestamp")
      nonce = request.args.get("nonce")
      echostr = request.args.get("echostr")

      # 校验参数
      if not all([signature, timestamp, nonce]):
          abort(400)

      # 按照微信的流程进行计算签名
      li = [WECHAT_TOKEN, timestamp, nonce]
      # 排序
      li.sort()
      # 拼接字符串
      tmp_str = "".join(li)
      # 进行sha1加密, 得到正确的签名值
      sign = hashlib.sha1(tmp_str.encode("utf-8")).hexdigest()

      # 将自己计算的签名值与请求的签名参数进行对比，如果相同，则证明请求来自微信服务器
      if signature != sign:
          # 表示请求不是微信发的
          abort(403)
      else:
          # 表示是微信发送的请求
          if request.method == "GET":
              # 表示是第一次接入微信服务器的验证
              echostr = request.args.get("echostr")
              if not echostr:
                  abort(400)
              return echostr
          elif request.method == "POST":
              # 表示微信服务器转发消息过来
              xml_str = request.data
              if not xml_str:
                  abort(400)

              # 对xml字符串进行解析
              xml_dict = xmltodict.parse(xml_str)
              xml_dict = xml_dict.get("xml")

              # 提取消息类型
              msg_type = xml_dict.get("MsgType")

              if msg_type == "text":
                  # 表示发送的是文本消息
                  # 构造返回值，经由微信服务器回复给用户的消息内容
                  resp_dict = {
                      "xml": {
                          "ToUserName": xml_dict.get("FromUserName"),
                          "FromUserName": xml_dict.get("ToUserName"),
                          "CreateTime": int(time.time()),
                          "MsgType": "text",
                          "Content": xml_dict.get("Content")
                      }
                  }
              else:
                  resp_dict = {
                      "xml": {
                          "ToUserName": xml_dict.get("FromUserName"),
                          "FromUserName": xml_dict.get("ToUserName"),
                          "CreateTime": int(time.time()),
                          "MsgType": "text",
                          "Content": "i love u"
                      }
                  }

              # 将字典转换为xml字符串
              resp_xml_str = xmltodict.unparse(resp_dict)
              # 返回消息数据给微信服务器
              return resp_xml_str


  if __name__ == "__main__":
      app.run(host="0.0.0.0", port=8000, debug=False)

  ```

###### 微信公众号配置(测试号)

1. 配置URL--`http://111.111.111.111/wechat8000`.
2. 配置token--`wechat`
3. 验证

#### 19-3-27

##### 切换用户

1. 切换到root`sudo su`或`su root`,使用一个`-`可以切换到对应的用户目录.
2. 切换到其他用户`su username`.
3. 更改root密码`sudo passwd root`.

##### 查看当前登录用户

1. `w`查看登录用户正在使用的进程信息
   1. `w -h`忽略头文件信息
   2. `w -u`显示结果的加载时间
   3. `w -s`不显示JCPU,PCPU,登录时间
2. `who`查看登录用户,显示用户名,tty号,时间日期,主机地址.
3. `users`显示当前登录的全部用户名称.
4. `whoami`显示自己,与`id -un`效果一样.
5. `who am i`显示更多的信息.
6. `last`显示特定用户登录系统的历史记录.如果没有指定任何参数,则显示所有用户的历史信息.

#### 19-3-30

##### 软件更新

1. `sudo apt upgrade`.
2. 列出已经安装的包`sudo apt list --installed`.
3. 下载的deb包在`/var/cache/apt/archives`.

##### 内核

1. 查看当前内核版本`uname -a`.
2. 查看全部内核`sudo dpkg --get-selections | grep linux-image`.
3. 升级安装内核`sudo apt-get install linux-image-4.15.0-46-generic`.
4. 删除内核`sudo apt-get remove linux-image-4.15.0-29-generic`.
5. 删除`deinstall`的内核`sudo dpkg -P linux-image-4.15.0-29-generic`.

##### 配置vim

1. 配置vim`/etc/vim/vimrc`

    ```bash
    " The following are commented out as they cause vim to behave a lot
    " differently from regular Vi. They are highly recommended though.
    set showcmd     " Show (partial) command in status line.
    set showmatch       " Show matching brackets.
    set ignorecase      " Do case insensitive matching
    set smartcase       " Do smart case matching
    "set incsearch      " Incremental search
    "set autowrite      " Automatically save before commands like :next and :make
    "set hidden     " Hide buffers when they are abandoned
    set mouse=a     " Enable mouse usage (all modes)
    set number
    set wrap
    set ruler
    set tabstop=4
    ```

##### 终端配色

1. 在`.bashrc`中打开`force_color_prompt=yes`,打开彩色终端.
2. 配置`PS1='${debian_chroot:+($debian_chroot)}\[\033[03;34;01m\]\u\[\033[00;32;01m\]@\[\033[01;31;01m\]\h\[\033[00;37;01m\]:\[\033[01;35;01m\]\w \[\033[01;33;01m\]\$ \[\033[00;36;01m\]'`.

##### mysql客户端

1. 安装mysql客户端`sudo apt install mysql-client`.
2. 使用`mysql -h db4free.net -P 3306 -umy__sql -p`访问免费数据库.
3. 在`~/.bashrc`中添加简化命令`alias db4free="mysql -h db4free.net -P 3306 -umy__sql -p`.

##### 踢除用户

1. `pkill -kill -t pts/1`.
2. `skill -kill -t pts/1`.
3. `skill -stop -u user1`.
4. `skill -kill -u user1`杀死并注销user1.

#### 19-4-13

##### 软件升级

---

## 3-程序员面试宝典

### 19-3-28

#### 第一部分 求职过程

##### 第1章 应聘求职

[挖坑待填](#)

###### 渠道

###### 流程

##### 第2章 简历书写

[挖坑待填](#)

###### 简历注意事项

###### 简历模板

##### 第3章 求职五部曲

[挖坑待填](#)

###### 笔试

###### 电话面试

###### 面试

###### 签约

###### 违约

##### 第4章 职业生涯发展规划

[挖坑待填](#)

###### 缺乏工作经验的应届毕业生

###### 更换工作的程序员

###### 快乐的工作

#### 第二部分 C/Cpp程序设计

##### 第5章 程序设计基本概念

###### 5.1 赋值语句

1. 下列Cpp代码的结果?

    ```cpp
    int i = 1;
    void main(){
        int i = i;
    }
    ```

    **A. main里的i是一个未定义值**  
    B. main里的i为1  
    C. 编译器不允许  
    D. main里的i为0  
    解析: 在Cpp里这样写是合法的(但是不合理).`int i = i;`,变量i从声明的那一刻开始就是可见的了,所以main里的i与main外的i无关,因此i是一个未定义值.

2. 下列程序的结果是?

    ```cpp
    #include<iostream>
    using namespace std;
    int main(){
        int x=2, y, z;
        x *= (y=z=5); cout << x << endl;  // z=5 ==> y=z ==> x=x*y ==> x=2*5 ==> x=10
        z=3;
        x == (y = z); cout << x << endl;  // y=z ==> x==y? ==> x不变 ==> x=10
        x = (y == z); cout << x << endl;  // y==z? ==> x=1
        x = (y & z); cout << x << endl;  // y&z ==> 0011B&0011B ==> x=3
        x = (y && z); cout << x << endl;  // y&&z? ==> true&&true ==> x=1
        y=4;
        x = (y | z); cout << x << endl;  // y|z ==> 0100B|0011B ==> x=0111B ==> x=7
        x = (y || z); cout << x << endl;  // y||z? ==> true||true ==> x=1
        return 0;
    }
    ```

    解析: 10, 10, 1, 3, 1, 7, 1

3. 以下代码结果?

    ```cpp
    #include<iostream>
    using namespace std;
    int func(int x){
        int count = 0;
        while(x){
            count++;
            x=x&(x-1);
        }
        return count;
    }

    int main(){
        cout << func(9999) << endl;
        return 0;
    }
    ```

    **A. 8**  
    B. 9  
    C. 10  
    D. 11  
    解析: func(x)实际返回将x转换为二进制后包含1的数量,因此`9999: 10 0111 0000 1111B`包含8个1.

###### 5.2 递增语句

1. 比较两段代码的输出?
   1. 第一段

        ```cpp
        # include<iostream>
        using namespace std;
        int main(){
            int a,x;
            for(a=0,x=0;a<=1 && !x++;a++){  // 区别
                a++;
            }
            cout<<a<<x<<endl;
            return 0;
        }
        ```

   2. 第二段

        ```cpp
        #include<iostream>
        using namespace std;
        int main(){
            int a,x;
            for(a=0,x=0;a<=1 && !x++;){  // 区别
                a++;
            }
            cout<<a<<x<<endl;
            return 0;
        }
        ```

    * 解析:
      1. 第一段代码
         1. 初始化a=0,x=0
         2. a<=1和!x均为true,符合循环条件
         3. x++自增后为1
         4. 进入循环体,a自增为1
         5. 执行for语句中的a++,a自增为2
         6. *此时条件a<=1不成立,**由于短路原则**&&后面的语句不执行,因此x不变*
         7. 打印输出2和1
      2. 第二段代码
         1. 初始化a=0,x=0
         2. a<=1和!x均为true,符合虚幻条件
         3. x++自增后为1
         4. 进入循环体,a自增为1
         5. *此时条件a<=1成立,但!x为0,不满足循环条件,不执行循环体,但是**x++依然执行**,x自增为2*
         6. 打印输出1和2

2. 以下代码的输出?

    ```c
    #include<stdio.h>
    main(){
        int b=3;  // 我在这里做什么?
        int arr[]={6,7,8,9,10};
        int *ptr=arr;  // 书上代码错了
        *(ptr++)+=123;
        printf("%d,%d\n",*ptr,*(++ptr));
    }
    ```

    * 解析: C语言中printf计算参数时**从右向左压栈**.
        1. ptr===>arr[0] >>> *ptr为6.
        2. *ptr = *ptr+123,ptr++ >>> *ptr=arr[0]=129,ptr===>arr[1]
        3. printf从右向左压栈,先执行(++ptr) >>> ptr===>arr[2] >>> *ptr为8
        4. 输出两个*ptr,均为8

###### 5.3 编程风格

1. 你喜欢哪种代码写法?
   1. 写法1

       ```c
       if('A'==a){
           a++;
       }
       ```

   2. 写法2

       ```c
       if(a=='A'){
           a++;
       }
       ```

2. 你喜欢哪种代码写法?
   1. 写法1

        ```c
        for(i=0;i<8;i++){
            X = i+Y+J*7;
            printf("%d",x);
        }
        ```

   2. 写法2

        ```c
        S = Y+J*7;
        for(i=0;i<8;i++){
            printf("%d",i+S);
        }
        ```

* 解析:
  1. 第一种写法好,因为不允许对常量赋值,可以避免将`==`错写为`=`的情况.
  2. 第二种写法好,将部分重复运算放到循环体外,可以提高效率,但是程序不那么简洁.

###### 5.4 类型转换

1. 下面程序的运行结果是?

    ```cpp
    #include<iostream>
    #include<stdio.h>
    #include<string.h>
    #include<conio.h>
    using namespace std;
    int main()
    {
        float a = 1.0f;
        cout<<(int)a<<endl;
        cout<<&a<<endl;
        cout<<(int&)a<<endl;
        cout<<boolalpha<< ( (int)a == (int&)a )<<endl;  // 输出false
        float b=0.0f;
        cout<< (int)b <<endl;
        cout<<&b<<endl;
        cout<<(int&)b<<endl;
        cout<<boolalpha<< ( (int)b == (int&)b )<<endl;  // 输出true
        return 0;
    }
    ```

    * 解析:
      1. `cout<<(int&)a<<endl;`输出的是`1065353216`,而不是1.因为在内存里浮点数和整数的存储方式不同,**`(int&)a`相当于将该浮点数地址开始的sizeof(int)个字节当作int型的数据输出**,这取决于float数据在内存中的存储方式.
      2. `float a=1.0f`在内存中的表示都是`3f800000`,当`(int&)a`强制转换时,会把内存值`3f800000`当作int型输出,所以结果变成了`1065353216`(`0x3f800000`的十进制表示).
      3. `(int&)a == static_cast <int&>(a)`????
      4. `(int&)a 相当于*(int*)&a ; *(int*)(&a) ; *((int*)&a)`????

2. 下面程序的运行结果是?

    ```cpp
    #include<stdio.h>
    int main()
    {
        unsigned int a = 0xfffffff7;
        unsigned char i = (unsigned char)a;
        char* b = (char*)&a;
        printf("%08x, %08x",i,*b);
        return 0;
    }
    ```

    * 解析:
      1. 在X86系列机器中,数据的存储是"小端存储",即对于一个跨多个字节的数据,其低位存放在低地址字节,高位存放在高地址字节.比如一个int型数据`0x12345678`,存放在`0x00000000,0x00000001,0x00000002,0x00000003`中,那么`0x00000000`存放低位`0x78`,`0x00000003`存放高位`0x12`.
      2. `char* b = (char*)&a;`将`&a`强制转换成`char*`类型的指针,并且此时发生了截断.截断后,指针b只指向`0xf7`这个数据,又由于指针b是`char*`类型的,属于有符号数,所以**有符号数`0xf7`在printf的作用下输出`fffffff7`.**(首先提升为int,无符号用0扩充,有符号用1扩充????)
      3. 内置类型转换
         1. 混合类型,最宽的数据类型成为目标类型.
         2. 用一种类型的表达式赋值给另一种类型的对象,被赋值对象类型成为目标类型.
         3. 函数传参,形参类型为目标类型.
         4. 函数返回,返回类型为目标类型.
         5. 为防止精度丢失,类型总会被提升为较宽的类型.
         6. **所有含有小于整形的有序类型的算术表达式在计算之前其类型都会被转换为整形.**
            1. 如果一个类型是`long double`,那么另一个必然会被转换为`long double`.
            2. 否则,若其中一个为`double`,则另一个被转换为`double`.
            3. 否则,若其中一个为`float`,则另一个被转换为`float`.
            4. 否则,必然是某种数值类型.在确定目标提升类型之前,**所有小于`int`的整值类型都会有一个整形提升的过程.**
            5. 整形提升完成后,类型比较再次开始.

###### 5.5 运算符问题

1. 下面程序的运行结果?

    ```cpp
    #include <iostream>
    using namespace std;

    int main()
    {
        unsigned char a = 0xa5;
        unsigned char b = ~a >> 4 + 1;
        // cout<<b;
        printf("b=%d\n", b);
        return 0;
    }
    ```

    A:245   B:246   **C:250**   D:2
    * 解析:
      1. 考察两个知识点,类型转换和运算符优先级.
         1. 类型转换,对于`unsigned char b = ~a >> 4 + 1;`,编译器首先会把a和4提升为整形后在计算,完成后转换为`unsigned char`赋值给b.
         2. 优先级`~`高于`+`高于`>>`
            1. 先对`1010 0101`取反得`0101 1010`,再右移(4+1)位,结果为`0000 0010`.
         3. `~a`操作时,首先对a进行整形提升,a为无符号数,提升时左边补0,即`~0x0000 00a5`为`0xffff ff5a`,右移5位后`0x07ff ffffa`,截取后为`0xfa`,即`250`.
    ![运算符优先级](./images/Operator_precedence.png)

2. 用一个表达式,判断一个数X是否是2的N次方,不使用用循环语句.(**!(X&(X-1))**)

    解析:2,4,8,16这样的数转换为二进制后为10,100,1000,10000.将X-1后与X做按位与运算为0.

3. 下面代码

    ```cpp
    int f(int x, int y){
        return (x&y) + ((x^y)>>1);
    }
    ```

    f(729,271)=____  
    解析:`x&y`取相同的位与,结果为x和y相同位的和的一半,`x^y`取x和y不同的位,右移相当于除以2,所以相当于取两数的平均数.即`(729+271)/2=500`.

4. 利用位运算实现两个整数的加法运算.

    ```cpp
    int Add(int a,int b){
        if(b==0) retuen a;  // 没有进位的时候完成运算
        int sum, carry;
        sum = a ^ b;  // 完成第一步没有进位的加法运算
        carry = (a & b) << 1;  // 完成第二步进位并且进行左移运算
        return Add(sum,carry);  // 进行递归,相加
    }
    ```

###### 5.6 a,b交换与比较

1. 找出两个数中较大的?
   1. `int max = ((a+b) + abs(a-b))/2`
   2.   ```cpp
        int c = a-b;
        char *str2[2] = ["a Large ","b Large "];
        c = unsigned(c) >> (sizeof(int)*8 -1);  // 右移31位,看符号位????
        ```

2. 找出两数中最大的?

    ```cpp
    bool func(int a,int b ){
        return a>b;
    }
    int max(int a,int b){
        bool flag = func(a,b);
        return flag*a + (1-flag)*b;
    }
    ```

3. 写一个交换两数据的宏?
   1. 按位异或操作,比如交换9和5(只能为整形)

        ```cpp
        0000 1001(9)^0000 0101(5)  00001100(12)
        0000 1001(9)^0000 1100(12) 00000101(5)
        0000 1100(12)^0000 0101(5) 0000 1001(9)
        #define SWAP(a,b){  a= a^b;  b= a^b; a= a^b; }
        #define SWAP(a,b){  a^= b^ = a^ = b;  }
        ```

   2. 内存交换(适用于浮点数)

        ```cpp
        #define SWAP(a,b){
            char tempBuf[10];
            memcpy(tempBuf,&a,sizeof(a));
            memcpy(&a,&b,sizeof(b));
            memcpy(&b,tempBuf,sizeof(b));
        }
        ```

###### 5.7 c和c++的关系

1. 在c++程序中调用被c编译器编译后的函数,为什么要加`extern "C"`?

    * 答案:c++支持函数重载,c不支持函数重载.函数被c++编译后在库中的名字与c不同.假设某函数的原型为`void foo(int x,int y)`.该函数被c编译后在库中的名字为`_foo`,而c++编译后则类似`_foo_int_int`.c++提供了c连接交换指定符号`extern "C"`解决名字匹配问题.

2. 头文件中的`ifndef/define/endif`是干什么用的?

    * 答案:是条件编译的一种,除了防止头文件被重复引用,还可以防止重复定义(变量、宏或者结构).

3. 评价一下c与c++的各自特点.如果一个程序既需要大量运算,又要有一个好的用户界面,还需要与其他软件大量交流,应该怎样选择?

    * 答案:c是一种结构化语言,重点在于算法与数据结构.c程序的设计首先考虑的是如何通过一个过程,对输入进行运算得到输出.而对于c++,首先考虑的是如何构造一个对象模型,让这个模型能够契合与之对应的问题域,这样就可以通过获取对象的状态信息得到输出或实现过程控制.
    * 对于大规模数值计算,c/c++和Java/.NET之间没有明显的性能差异.不过,如果计算涉及向量计算,矩阵运算,可以使用FORTRAN或者MATLAB编写计算组件(如COM).
    * 大规模用户界面相关的软件可以考虑使用.NET开发(Windows环境),而且.NET同COM之间的互操作十分容易,同时对数据库访问的支持也相当好.

###### 5.8 程序设计的其他问题

1. 下面的switch语句输出什么?

   ```cpp
    #include <iostream>
    using namespace std;
    int main()
    {
        int n = 'c';
        switch (n++)
        {
        default:
            printf("error");
            break;
        case 'a':
        case 'A':
        case 'b':
        case 'B':
            printf("ab");
            break;
        case 'c':
        case 'C':
            printf("c");
        case 'd':
        case 'D':
            printf("d");
        }
        return 0;
    }
   ```

   解析:如果switch中的case语句后面不加break,就会依次执行下去.因此,从`c`开始查找,输出`c`,之后继续输出'd',最终输出`cd`.

2. 上机题目描述:选秀节目打分,分为专家评委和大众评委,`score[]`数组里面存储每个评委打的分数,`judge_type[]`里存储与`score[]`数组对应的评委类别,judge_type==1表示专家评委,judge_type==2,表示大众评委,n表示评委总数.打分规则如下:专家评委和大众评委的分数先分别取一个平均分(平均分取整),然后,`总分`=专家评委平均分`*`0.6+大众评委平均分`*`0.4,总分取整.函数最终返回选手得分.函数接口`int cal_score(int Score[], int Judge_type[], int N)`.

    ```cpp
    int cal_score(int Score[], int Judge_type[], int N){
        int ret=0,n=0,m=0;
        double sum1=0,sum2=0;
        if(N&&Score&&Judge_type){
            for(int i=0;i<N;++i){
                switch(Judge_type[i]){
                    case 1: sum1+=Score[i]; ++n; break;
                    case 2: sum2+=Score[i]; ++m; break;
                    default:break;
                }
            }
            if(n){
                sum1 = int(sum1/n);
            }
            if(m){
                sum2 = int(sem2/m);
            }
            ret = m?sum1*0.6+sum2*0.4:sum1;
        }
        return ret;
    }
    ```

### 19-3-29

##### 第6章 预处理,const与sizeof

###### 6.1 宏定义

1. 下面代码输出结果?

    ```c
    #include <stdio.h>
    #define SUB(x, y) x - y
    #define ACCESS_BEFORE(element, offset, value) *SUB(&element, offset) = value

    int main(int argc, char const *argv[])
    {
        int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        ACCESS_BEFORE(array[5], 4, 6);  // 此处报错
        for (size_t i = 0; i < 10; i++)
        {
            printf("%d", array[i]);
        }

        return 0;
    }
    ```

    A. array:1 6 3 4 5 6 7 8 9 10  
    B. array:6 2 3 4 5 6 7 8 9 10  
    C. 程序可以正常编译,但是运行时崩溃  
    **D. 程序语法错误,编译不成功**  

    * 解析:宏的预处理被替换成了`*&array[5]-4=6`,优先处理减号,返回一个右值,所以编译报错.

2. 用预处理指令#define声明一个常数,用以表明一年中有多少秒(忽略闰年)

    * 解析:`#define SECONDS_PER_YEAR (60 * 60 *24 * 365)UL`

3. 写一个标准宏MIN,输入两个参数返回较小的一个.

    * 解析:`#define MIN(A, B) ((A)<=(B)?(A):(B))`

###### 6.2 const

1. 哪个const应该被移除?

    ```cpp
    #include <iostream>
    #include <windows.h>
    #define BUF_SIZE 30

    using namespace std;

    class A
    {
      private:
        const /* C */ BYTE *const /* D处应被移除 */ m_pBuf;

      public:
        A();
        ~A(){};
        inline const /* A */ BYTE *GetBuffer() const /* B */ { return m_pBuf; }
        int Pop(void);
    };

    A::A() : m_pBuf()
    {
        BYTE *pBuf = new BYTE[BUF_SIZE];
        if (pBuf == NULL)
        {
            return;
        }
        for (size_t i = 0; i < BUF_SIZE; i++)
        {
            pBuf[i] = i;
        }
        m_pBuf = pBuf; // 此处报错
    }

    int main(int argc, char const *argv[])
    {
        A a;
        const/* E */ BYTE *pB = a.GetBuffer();
        if (pB != NULL)
        {
            for (size_t i = 0; i < BUF_SIZE; i++)
            {
                printf("%u", pB[i++]);
            }
        }
        system("pause");

        return 0;
    }
    ```

    * 解析:
      1. const位于*号左侧,底层const,用于修饰整值指向的变量,可以不初始化指针.不可以通过指针修改变量.但是可以将指针指向别处或从别处修改变量.
      2. const位于*号右侧,顶层const,用于修饰指针本身,必须初始化指针,且不可以更改指针的指向.但是可以通过指针改变变量.
      3. 两个const,指针本身和所指变量均不可以改变.
      4. const成员函数为只读函数,不可以修改数据成员或者调用非const成员函数.

2. const和#define有什么区别?
   
   *解析:C++中可以使用const或者#define定义常量,但前者比后者有更多的优点:
      1. const常量有数据类型,而宏常量没有数据类型.对前者可以进行类型安全检查,后则只进行简单的字符串替换,并且可能出错.
      2. 部分集成化调试工具可以对const变量进行调试,c++中const可以完全替代宏.
   * 扩展知识:
      1. c++中的const,不会分配内存,而是直接写入符号表中,成为一个编译期间的常量(常量折叠),即使强制分配地址并修改也没有效果,因为直接从符号表中取值.
      2. c中的const会分配内存,通过地址可以直接更改."一个不可以被改变的普通变量",c编译器不会把const看作一个编译期间的常量.
      3. c默认const是外部链接的,而c++默认const是内部链接的.

3. const成员函数如何修改成员变量?

    * 解析:在C++中,给类的数据成员加上`mutable`后,即使是const成员函数也可以修改它.

### 19-4-2

#### 第6章(续)

##### 6.3 sizeof

1. 下面代码的输出是什么?

    ```cpp
    #include <iostream>
    #include <stdio.h>
    #include <string.h>

    using namespace std;

    struct
    {
        short a1;
        short a2;
        short a3;
    } A;

    struct
    {
        long a1;
        short a2;
    } B;

    int main(int argc, char const *argv[])
    {
        char *ss1 = "0123456789";
        char ss2[] = "0123456789";
        char ss3[100] = "0123456789";
        int ss4[100];
        char q1[] = "abc";
        char q2[] = "a\n";
        char *q3 = "a\n";
        char *str1 = (char *)malloc(100);
        void *str2 = (void *)malloc(100);

        cout << sizeof(ss1) << " ";
        cout << sizeof(ss2) << " ";
        cout << sizeof(ss3) << " ";
        cout << sizeof(ss4) << " ";
        cout << sizeof(q1) << " ";
        cout << sizeof(q2) << " ";
        cout << sizeof(q3) << " ";
        cout << sizeof(A) << " ";
        cout << sizeof(B) << " ";
        cout << sizeof(str1) << " ";
        cout << sizeof(str2) << " ";

        return 0;
    }
    ```

    * 解析:
      1. 指针的大小是定值,为4.
      2. 字符数组要加上最后的`\0`;
      3. 结构体考虑内存对齐:
         1. 当结构体内的元素长度都小于处理器的位数时,以结构体中最长数据元素为对齐单元,即结构体长度一定是最长数据元素长度的整数倍.
         2. 当结构体内的某个元素长度大于处理器的位数时,以处理器位数为对齐单元,即结构体长度一定是处理器位数的整数倍.
      4. CPU的优化规则:对于n字节的元素,它的首地址能被n整除,才能获得最好的性能.
      5. 数据对齐:数据所在的内存地址必须是该数据长度的整数倍,但是不同编译器优化结果不同.
      6. 答案:`4 11 100 400 4 3 4 6 8 4 4`.

2. 以下代码在32位机器编译,数据以4字节为对齐单位,输出结果为什么不同?

    ```cpp
    class B
    {
      private:
        bool m_bTemp;
        int m_nTemp;
        bool m_bTemp2;
    }
    class C
    {
      private:
        int m_nTemp;
        bool m_bTemp;
        bool m_bTemp2;
    }

    cout << sizeof(B) << endl;
    cout << sizeof(C) << endl;

    ```

    * 解析:
      1. 在访问内存时,地址按对齐单位访问,效率会高很多,原因在于访问内存的硬件电路,一般情况下,地址总线总是按照对齐后的地址来访问.
      2. 在VC中,可以通过`pack`预处理指令来禁止对齐策略.除非必要,否则不要用:
         1. 需要将结构写入文件;
         2. 需要将结构通过网络传输给其他程序.
      3. 字节对齐是在编译时决定的.
      4. 答案:`12 8`.

3. 下面程序的输出结果?

    ```cpp
    #include <iostream>

    using namespace std;

    class A1
    {
      public:
        int a;
        static int b;

        A1();
        ~A1();
    };
    class A2
    {
      public:
        int a;
        char c;

        A2();
        ~A2();
    };
    class A3
    {
      public:
        float a;
        char c;

        A3();
        ~A3();
    };
    class A4
    {
      public:
        float a;
        int b;
        char c;

        A4();
        ~A4();
    };
    class A5
    {
      public:
        double d;
        float a;
        int b;
        char c;

        A5();
        ~A5();
    };

    int main(int argc, char const *argv[])
    {
        cout << sizeof(A1) << endl;
        cout << sizeof(A2) << endl;
        cout << sizeof(A3) << endl;
        cout << sizeof(A4) << endl;
        cout << sizeof(A5) << endl;

        return 0;
    }
    ```

    * 解析:
      1. sizeof()计算栈中分配的大小;
      2. 答案:`4 8 8 12 24`.

4. 说明sizeof和strlen的区别?
   1. sizeof操作符的结果类型是size_t,它在头文件中的typedef为unsigned int类型,该类型保证能容纳实现所建立的最大对象的字节大小;
   2. sizeof是运算符,strlen是函数;
   3. sizeof可以使用类型做参数,strlen只能使用char*做参数,且必须以`\0`结尾.sizeof可以使用函数做参数,使用的是函数的返回值;
   4. 数组做sizeof的参数不退化,传递给strlen就退化成指针;
   5. 大部分编译器在**编译**的时候就把sizeof计算过了.因此sizeof()可以用来定义数组的维数;
   6. strlen的结果在运行时计算;
   7. sizeof后如果是类型必须加括号,如果是变量名可以不加括号,这是因为sizeof是个操作符而不是函数;
   8. sizeof不能返回被动态分配的数组或外部的数组的尺寸;
   9. 数组作为参数传递给函数时传递的是数组的首地址,函数内无法获得数组的大小;
   10. 计算结构变量的大小就必须讨论数据对齐问题,可以使用`#pragma pack(n)`调整,或关闭`Data Alifnment`选项;
   11. sizeof不能用于函数类型,不完全类型或位字段.
5. 说明sizeof的使用场合?
   1. 与存储分配和I/O系统那样的例程进行通信;
   2. 查看在内存中所占的空间;
   3. 动态分配对象时,指定内存大小;
   4. 便于类型的扩充;
   5. 使用sizeof代替常量计算;
   6. 函数中的形参为数组或函数时,给出指针的大小.
6. `int **a[3][4]`占据多大空间?
   1. 3×4×4(指针)=48.
7. 找出下列程序的错误并解释?

    ```cpp
    #include <iostream>
    #include <string>

    using namespace std;

    int main(int argc, char const *argv[])
    {
        // To output "TrendNicroSoftUSCN"

        string strArr1[] = {"Trend", "Micro", "Soft"};
        string *pStrArr1 = new string[2];
        pStrArr1[0] = "US";
        pStrArr1[1] = "CN";
        for (size_t i = 0; i < sizeof(strArr1) / sizeof(string); i++)
        {
            cout << strArr1[i];
        }
        for (size_t j = 0; j < sizeof(pStrArr1) / sizeof(string); j++)  // 有错误
        {
            cout << pStrArr1[j];
        }
        cout << endl
            << sizeof(string) << endl;  // 24
        cout << sizeof(strArr1) << endl;  // 72
        cout << sizeof(pStrArr1) << endl;  // 4
        return 0;
    }
    ```

    * 解析:
      1. sizeof问题,第二个for中的sizeof计算的是指针大小,因此输出不全;
      2. sizeof是个类似宏定义的特殊关键字,sizeof()括号中的内容在编译期间不被编译,而是被替代类型;

         ```cpp
         int a = 8;
         sizeof(a);  // 被替换为sizeof(int)
         sizeof(a=6);  // 因为a=6不被编译,所以a还是8
         ```

      3. 对函数使用sizeof,在编译阶段会被函数的返回值类型取代.

8. 下面程序的结果?

    ```cpp
    #include <iostream>
    #include <complex>

    using namespace std;

    class Base
    {
      public:
        Base()
        {
            cout << "Base-ctor" << endl;
        }
        ~Base()
        {
            cout << "Base-dtor" << endl;
        }
        virtual void f(int)
        {
            cout << "Base::f(int)" << endl;
        }
        virtual void f(double)
        {
            cout << "Base::f(double)" << endl;
        }
        virtual void g(int i = 10)
        {
            cout << "Base::g()" << i << endl;
        }
        void g2(int i = 10)
        {
            cout << "Base::g2()" << i << endl;
        }
    };

    class Derived : public Base
    {
      public:
        Derived()
        {
            cout << "Derived-ctor" << endl;
        }
        ~Derived()
        {
            cout << "Derived-dtor" << endl;
        }
        void f(complex<double>)
        {
            cout << "Derived::f(complex)" << endl;
        }
        virtual void g(int i = 20)
        {
            cout << "Derived::g()" << i << endl;
        }
    };

    int main(int argc, char const *argv[])
    {
        cout << sizeof(Base) << endl;
        // A.4  B 32  C. 20
        cout << sizeof(Derived) << endl;
        // A.4  B.8  C.36

        return 0;
    }
    ```

    * 解析:
      1. 因为只有一个指向虚函数表的指针,所以都是4.

9. 下面程序的结果是?

    ```cpp
    char var[10];
    int test(char var[]){
      return sizeof(var);
    }
    ```

       * 解析:退化为指针,所以结果为4.

10. 下面代码的输出结果是?

    ```cpp
    class B
    {
      float f;
      char p;
      int adf[3];
    };
    cout << sizeof(B);
    ```

    * 解析:考虑对齐,结果为`4 + [1+3] + 12 = 20`.

11. 一个空类占多少空间?多重继承的空类?

    ```cpp
    #include <iostream>

    using namespace std;

    class A
    {
    };
    class A2
    {
    };
    class B : public A
    {
    };
    class C : public virtual B
    {
    };
    class D : public A, public A2
    {
    };

    int main(int argc, char const *argv[])
    {
        cout << "sizeof(A)" << sizeof(A) << endl;
        cout << "sizeof(B)" << sizeof(B) << endl;
        cout << "sizeof(C)" << sizeof(C) << endl;
        cout << "sizeof(D)" << sizeof(D) << endl;

        return 0;
    }
    ```

    * 解析:`1 1 4 1`
      1. 空类占1;
      2. 单一继承的空类占1;
      3. 多重继承的空类占1;
      4. 虚继承涉及虚指针,占4.

##### 6.4 内联函数和宏定义

* 内联函数和宏的差别是?
  1. 内联函数和普通函数比可以加快速度,因为不需要中断调用,编译时内联函数直接镶嵌到目标代码中,而宏只是简单的替换;
  2. 内联函数要做类型检查;
  3. 对于短小的代码,内联函数和宏都是增加空间换来效率的提升,但是内联函数在没有付出任何代价的前提下更安全;
  4. 宏在C语言里很重要,在C++里最好永远不用;
  5. 宏不是函数,只是在编译前(编译预处理阶段)进行字符串替换;
  6. 关键字`inline`必须与函数定义体放在一起才能有用,是一种"用于实现的关键字",而不是"用于声明的关键字";
  7. 内联函数以代码膨胀为代价,仅仅省去了函数调用的开销,如果函数运行时间长,那么将没有意义;
  8. 每一处内联函数都要复制代码,使程序变大,消耗更多内存空间;
  9. 以下情况不适用内联函数:
     1. 函数体代码较长;
     2. 函数体内有循环等;
  10. 使用inline关键字,编译器决定是否使函数成为内联.

### 19-4-4

##### 第7章 指针与引用

###### 7.1 指针基本问题

1. 指针与应用的区别？
   1. 非空区别。引用不可能指向空值，指针可以指向空指针。
   2. 合法性区别。使用引用之前不需要验证，使用指针前总要验证非空。
   3. 可修改区别。指针可以重新赋值以指向新的对象，引用总是指向初始化时所指定的对象。
   4. 应用区别。考虑可以指向空对象或者指向不同对象时使用指针，考虑只指向一个对象且不改变指向则使用引用。
2. 判断程序何处错误？

    ```cpp
    #include <iostream>

    using namespace std;

    int main(int argc, char const *argv[])
    {
        int iv;                      // 1 正确
        int iv2 = 1024;              // 2 正确
        int iv3 = 999;               // 3 正确
        int &reiv;                   // 4 错误，引用未初始化。
        int &reiv2 = iv;             // 5 正确
        int &reiv3 = iv;             // 6 正确
        int *pi;                     // 7 正确
        *pi = 5;                     // 8 错误，野指针。
        pi = &iv3;                   // 9 正确
        const double di;             // 10 错误，常量应初始化。
        const double maxWage = 10.0; // 11 正确
        const double minWage = 0.5;
        const double *pc = &maxWage; // 13 正确

        return 0;
    }
    ```

###### 7.2 传递动态内存

1. 下面5个函数哪个能成功进行两数交换？

    ```cpp
    #include <iostream>

    using namespace std;

    void swap1(int p, int q)
    {
        int temp;
        temp = p;
        p = q;
        q = temp;
    }
    void swap2(int *p, int *q)
    {
        int *temp;
        *temp = *p;
        *p = *q;
        *q = *temp;
    }
    void swap3(int *p, int *q)
    {
        int *temp;
        temp = p;
        p = q;
        q = temp;
    }
    void swap4(int *p, int *q)  // 可以
    {
        int temp;
        temp = *p;
        *p = *q;
        *q = temp;
    }
    void swap5(int &p, int &q)  // 可以
    {
        int temp;
        temp = p;
        p = q;
        q = temp;
    }
    int main(int argc, char const *argv[])
    {
        int a = 1, b = 2;
        // swap1(a, b);
        // swap2(&a, &b);
        // swap3(&a, &b);
        // swap4(&a, &b);
        // swap5(a, b);
        cout << a << "  " << b << endl;

        return 0;
    }
    ```

    * 解析：
      1. swap1值传递，局部变量不会影响主函数；
      2. swap2解引用未初始化的指针，未定义行为；
      3. swap3局部变量指针的指向变化，但地址中的值没变；
      4. swap4直接修改指针所指向地址中的值；
      5. swap5引用传递，可以直接修改原对象。

2. 程序测试结果？

    ```cpp
    #include <iostream>
    #include <cstring>

    using namespace std;

    void GetMemory(char *p, int num)
    {
        p = (char *)malloc(sizeof(char) * num);
    }

    int main(int argc, char const *argv[])
    {
        char *str = nullptr;
        str = GetMemory(str, 100);
        strcpy(str, "hello");
        // cout << str;
        return 0;
    }
    ```

    * 解析：GetMemory函数中仅仅修改了局部变量指针，不会影响外部变量，申请的内存没有释放，造成内存泄漏。可以使用指向指针的指针或返回值。

3. 函数有什么问题？

    ```cpp
    char *strA(){
      char str[] = "hello world";
      return str;
    }
    ```

    * 解析：
      1. 局部数组在函数返回后被销毁，不应该被访问，属于未定义行为；
      2. 可以使用`char *sre = "hello world";`或者`static char str[] = "hello world";`；
      3. 局部数组是局部变量，对应内存中的栈；
      4. 指针变量是全局变量，对应内存中的全局区域；
      5. 字符串常量保存在只读的数据段，而不是像全局变量那样保存在普通数据段（静态存储区）。

4. 下面程序的运行结果?

    ```cpp
    int a[3];
    a[0]=0;a[1]=1;a[2]=2;
    int *p,*q;
    p=a;
    q=&a[2];
    cout<<a[q-p];  // a[2]  2
    ```

    * 解析：`q-p`的值为`(id(q)-id(p))/sizeof(int)`为2，即输出a[2]的值。

5. 下面代码的运行结果？

    ```cpp
    #include <iostream>

    using namespace std;
    class A
    {
      private:
        int m_a;
        int m_b;

      public:
        A()
        {
            m_a = 1;
            m_b = 2;
        }
        ~A() {}
        void fun()
        {
            printf("%d%d", m_a, m_b);
        }
    };
    class B
    {
      private:
        int m_c;

      public:
        B() { m_c = 3; }
        ~B() {}
        void fun()
        {
            printf("%d", m_c);
        }
    };

    int main(int argc, char const *argv[])
    {
        A a;
        B *pb = (B *)(&a);
        pb->fun();  // 1

        return 0;
    }
    ```

    * 解析：
      1. 考察内存偏移；
      2. 指针pb指向的是对象的内存首地址；
      3. `pb->fun()`调用时，编译器对于m_c的认识就是距离对象首地址的偏移量为0；
      4. 因此打印m_a的值。

6. 下面代码的运行结果？

    ```cpp
    int *ptr;
    ptr=(int*)0x8000;
    *ptr=0xaabb;
    ```

    * 解析：给指针分配了一个随机的地址，并修改了指针指向的对象，未定义行为。

7. 下面代码的运行结果？

    ```cpp
    #include <iostream>

    using namespace std;
    class A
    {
      public:
        int _a;
        A() { _a = 1; }
        ~A(){};
        void print()
        {
            printf("%d", _a);
        }
    };
    class B : public A
    {
      public:
        int _a;
        B() { _a = 2; }
        ~B(){};
    };

    int main(int argc, char const *argv[])
    {
        B b;
        b.print();  // 1
        printf("%d", b._a);  // 2
        return 0;
    }
    ```

    * 解析：
      1. B中的_a把A中的_a隐藏了；
      2. B构造时，先调用A的构造函数，所以A中_a为1，而B中为2。

8. 以下描述正确的是？
   1. 函数的形参在函数未调用时预分配存储空间           // 调用时才分配局部空间
   2. 若函数的定义出现在主函数之前，则可以不必加说明    // 函数需要在被调用之前声明，与main无关
   3. 若函数没有retuen语句，则什么值也不返回           // main可以不写return，默认返回0；在一般函数中不能没有return 
   4. 一般来说，函数的形参和实参的类型应该一致          // 正确
9. 下面程序会在哪一行崩溃？

    ```cpp
    struct S{
      int i;
      int *p;
    };
    int main(){
      S s;
      int *p=&s.i;
      p[0]=4;
      p[1]=3;
      s.p=p;
      s.p[1]=1;
      s.p[0]=2;  // 出错
    }

    * 解析：😥

---

## 4-python官方文档

### ~~>>>1入门教程{19-4-1}~~

#### 19-3-24

##### 1课前甜点

##### 2使用python解释器

###### 调用解释器

1. 传入参数
2. 交互模式

###### 解释器的运行环境

* 源文件的字符编码
  1. `# -*- coding:encoding -*-`.
  2. unix

      ```shell
      #!/usr/bin/env python3
      # -*- coding:utf-8 -*-
      ```

##### 3python的非正式介绍

###### 作为计算器使用

1. 数字
2. 字符串
3. 列表

###### 走向编程的第一步

1. 循环赋值
2. while语句
3. 缩进
4. print()函数

##### 4其他流程控制工具

###### if语句

* elif
* else

###### for语句

1. 一个迭代器.
2. 对任意序列进行迭代.
3. 修改需要使用副本.

###### range()函数

1. 可迭代的对象.
2. enumerate()枚举.

###### break和continue语句,以及循环中的else子句

* 循环语句可以带一个`else`子句,没有break跳出时执行该子句.

###### pass语句

1. 最小类
2. 占位符

###### 定义函数

1. 文档字符串
2. 本地作用域
3. 全局变量不能在函数中赋值,使用`global`例外.
4. 参数按照引用传递.

###### 函数定义的更多形式

1. 参数默认值.
   1. 默认值是在定义过程中在函数定义处计算的,只会计算一次,传递可变对象时会共享一个,尤为重要.
2. 关键字参数
   1. 关键字参数必须跟随在位置参数的后面.
3. 任意的参数列表
4. 解包参数列表
5. lambda表达式
6. 文档字符串
   1. 第一行简洁描述对象目的,以大写字母开头,句点结尾.
   2. 多行时第二行为空白.
7. 函数标注
   1. 元数据信息
   2. 函数标注以字典的形式存放在函数的`__annotations__`中.
   3. 形式为在形参名称后加上冒号,后跟一个表达式;返回值标注的形式是加上一个`->`,后跟一个表达式.

###### 小插曲:编码风格

1. 使用4个空格缩进,不使用制表符.
2. 换行.
3. 使用空行分隔函数和类以及较大的代码块.
4. 注释单独放一行.
5. 使用文档字符串.
6. 运算符前后和逗号后使用空格.
7. 类使用大驼峰命名,函数和方法使用下划线分割小写字符命名.

##### 5数据结构

###### 列表的更多特性

1. list.append(x)
2. list.extend(iterable)
3. list.insert(i, x)
4. list.remove(x)
5. list.pop([i])
6. list.clear()
7. list.index(x[start,[,end]])
8. list.count(x)
9. list.sort(key=None, reverse=False)
10. list.reverse()
11. list.copy()

###### 列表作为栈使用

###### 列表作为队列使用

###### 列表推导式

###### 嵌套的列表推导式

###### del语句

###### 元组和序列

###### 集合

###### 字典

1. 键值对
2. list(dict)返回键的列表
3. 字典推导式

###### 循环的技巧

1. dict.items()
2. enumerate(list)
3. zip(list1,list2)
4. 逆序reversed(list)
5. 排序sorted(list)

###### 深入条件控制

1. in / not in
2. is / is not
3. **比较操作符可以传递`a < b == c`会检验`a小于b并且b等于c`.**
4. and / or / not
5. python赋值操作不能发生在表达式内部.

###### 序列和其他类型的比较

1. 按照字典序依次比较.
2. 对于不同类型,只要提供了合适的比较方法即可.

##### 6模块

1. 编写脚本.
2. 模块名可以通过全局变量`__name__`获得.

###### 有关模块的更多信息

1. 可执行语句仅在第一次被导入时才执行.
2. 私有作用域.
3. `from module import some1, some2 [as aaa]`
4. `from module import *`导入所有非下划线开头的名称.
5. 需要重新导入模块时

    ```py
    import importlib
    importlib.reload(modulename)
    ```

###### 以脚本的方式执行模块

1. `pythom mudule.py <arguments>`,此时`__name__`被赋值为`__main__`.
2. `if __name__ == __main__:`

###### 模块搜索路径

1. 首先寻找具有该名称的内置模块.
2. 如果没有找到,会从`sys.path`变量给出的目录列表里寻找.
   1. 包含输入脚本的目录(或者没指定文件时的当前目录).
   2. `PYTHONPATH`一个包含目录名称的列表.
   3. 取决于安装的默认位置.
3. 初始化后,python程序可以更改`sys.path`.当前目录被放在搜索目录的开头处,在标准库路径之前.

###### "编译过的"Python文件

1. 为了加快模块载入,python在`__pychche__`目录中缓存每个模块的编译后版本,名字为`module.version.pyc`.
2. 编译的文件与平台无关.
3. 在两种情况下,不会检查缓存
   1. 从命令行载入的模块直接编译且不会存储编译结果.
   2. 没有源模块时不会检查缓存.
4. 可以有无源文件发行版本.
5. 可以控制编译文件的大小.
6. 运行速度不会快,仅仅提高了载入的速度.
7. `compileall`模块可以为一个目录下的所有文件创建`.pyc`文件.

###### 标准模块

* python自带标准模块库
   1. 取决于底层平台.
   2. 模块`sys`被内嵌到解释器中,变量`sys.ps1`和`sys.ps2`定义用作主要和辅助提示的字符串.仅在交互模式下才被定义.
   3. `sys.path`是一个字符串列表,用于确定解释器的模块搜索路径.

###### dir()函数

1. 内置函数`dir()`用于查找模块定义的名称,返回一个排序过的字符串列表.
2. 如果没有参数,返回当前定义的名称.
3. 不会列出内置函数和变量的名称.如果需要,可以使用`dir(builtins)`.

###### 包

1. 包是一种通过用"带点号的模块名"来构造Python模块命名空间的方法.
2. 模块集合,避免名称重复.
3. 为了让Python将目录当做包,目录中必须包含`__init__.py`文件,可以做初始化工作.

###### 从包中导入*

1. 不推荐使用.
2. 包的显式索引,在包的`__init__.py`中定义一个`__all__`的列表,可以显式指明应该道路的模块名.

###### 子包参考

1. 当包被构造成子包时,你可以使用绝对导入来引用兄弟包的子模块.
2. 相对导入是基于当前模块的名称进行导入的.由于主模块的名称总是"__main__",因此用作Python应用程序主模块的模块必须始终使用绝对导入.

###### 多个目录中的包

1. 包支持另一个特殊属性`__path__`.它被初始化为一个列表,其中包含在执行该文件中的代码之前保存包的文件`__init__.py`的目录的名称.这个变量可以修改;这样做会影响将来对包中包含的模块和子包的搜索.
2. 虽然通常不需要此功能,但它可用于扩展程序包中的模块集.

#### 19-3-25

##### 7输入输出

###### 更漂亮的输出格式

1. 格式化字符串字面值.`f"string {变量1} {变量2}"`.
2. 字符串的`str.format()`.
3. `repr()和str()`
   1. `str()`返回人类可读的表示
   2. `repr()`生成解释器可读的表示
   3. 多数时候返回值一样,一种特殊情况为字符串

###### 格式化字符串字面值(f-字符串)

1. 在字符串前加上f和F并将表达式写成{expression}来在字符串中包含Python表达式的值.
2. 可选的格式说明符可以跟在表达式后面.
3. 在':'后传递一个整数可以让该字段成为最小字符宽度.
4. 其他的修饰符可用于在格式化之前转化值.'!a'应用ascii(),'!s'应用str(),还有'!r'应用repr().

###### 字符串的格式化方法

1. 花括号和其中的字符(称为格式字段)将替换为传递给`str.format()`方法的对象.花括号中的数字可用来表示传递给`str.format()`方法的对象的位置.
2. 如果在`str.format()`方法中使用关键字参数,则使用参数的名称引用它们的值.
3. 位置和关键字参数可以任意组合.
4. 可以直接传递字典参数,使用`[]`或者`**`.
5. 在与内置函数`vars()`结合使用时非常有用,它会返回包含所有局部变量的字典.

###### 手动格式化字符串

1. `str.rjust()`填充空格.
2. `str.ljust()`.
3. `str.center()`.
4. `str.zfill()`在字符串左边填充0,可以识别正负号.

###### 旧的字符串格式化方法

* `%`操作符用作字符串格式化.

###### 读写文件

1. `open(filename, mode)`,返回`fiel object`.
2. 读,写,追加,二进制.
3. 在文本模式下读取时,会转换行结束符(unix下`\n`,windows下`\r\n`),会破坏二进制文件格式.
4. 最好使用`with`,不适用python要自己`close`.

###### 文件对象的方法

1. `f.read(size)`
2. `f.readline()`换行符在字符串的末尾.
3. 循环遍历文件对象,`for line in f:`
4. `list(f)`或`f.readlines()`列表形式.
5. `f.write(string)`返回写入的字符数,写入字符串或者字节对象.
6. `f.tell()`返回文件对象在文件中的位置.
7. `f.seek(offset, from_what)`调整文件对象的位置.
8. 在文本文件(那些在模式字符串中没有`b`的打开的文件)中,只允许相对于文件开头搜索(使用`seek(0, 2)`搜索到文件末尾是个例外)并且唯一有效的offset值是那些能从`f.tell()`中返回的或者是零.其他offset值都会产生未定义的行为.

###### 使用JSON保存结构化数据

1. `json.dumps(object)`返回json字符串.
2. `json.loads(string)`返回被封装的对象.
3. `json`可以处理列表和字典,但是无法直接序列化任意类.
4. `pickle`协议允许对任意python对象进行序列化,为python特有,默认情况下不安全,反序列化时可以执行任意代码.

#### 19-3-27

##### 8错误和异常

* 语法错误和异常.

###### 语法错误(解析错误)

* `invalid syntax`,文件名和行号以及一个箭头.

###### 异常

1. 异常类型,异常信息.
2. 标准的异常类型是内置的标识符(不是保留关键字).
3. 源代码行的堆栈回溯.

###### 处理异常

1. 首先,执行try子句(try和except关键字之间的(多行)语句).
2. 如果没有异常发生,则跳过except子句并完成try语句的执行.如果在执行try子句时发生了异常,则跳过该子句中剩下的部分.然后,如果异常的类型和except关键字后面的异常匹配,则执行except子句,然后继续执行try语句之后的代码.
3. 如果发生的异常和except子句中指定的异常不匹配,则将其传递到外部的try语句中;如果没有找到处理程序,则它是一个`未处理异常`,执行将停止并显示如上所示的消息.
4. 一个try语句可以有多个ecxept子句.
5. 一个except子句可以将多个异常命名为带括号的元组`except (RuntimeError, TypeErroe, NameErroe)`.
6. except子句匹配,派生类在上面,基类在下面,通用的在最下面.
7. except子句可以重新引发异常.
8. 有一个可选的else子句,不引发异常时执行.
9. 发生异常时,它可能具有关联值,也称为异常参数.参数的存在和类型取决于异常类型.
10. except子句可以在异常名称后面指定一个变量.这个变量和一个异常实例绑定,它的参数存储在`instance.args`中.为了方便起见,异常实例定义了`__str__()`,因此可以直接打印参数而无需引用`.args`.也可以在抛出之前首先实例化异常,并根据需要向其添加任何属性.
11. 如果异常有参数,则它们将作为未处理异常的消息的最后一部分('详细信息')打印.
12. 异常处理程序不仅处理try子句中遇到的异常,还处理try子句中调用(即使是间接地)的函数内部发生的异常.

###### 抛出异常

1. raise语句允许程序员强制发生指定的异常.
2. raise唯一的参数就是要抛出的异常.

###### 用户自定义异常

1. 程序可以通过创建新的异常类来命名它们自己的异常,继承自`Exception`.

###### 定义清理操作

1. try语句有另一个可选子句finally,用于定义必须在所有情况下执行的清理操作.
2. finally一定会执行,对于释放外部资源非常有用.

###### 预定义的清理操作

* `with`语句允许像文件这样的对象能够以一种确保它们得到及时和正确的清理的方式使用.

#### 19-3-28

##### 9类

1. 多个基类,多继承.
2. 类成员通常都是public(除了私有变量),所有成员函数都是virtual.
3. 没有用于从其方法引用对象成员的简写:方法函数使用表示对象的显式第一个参数声明,该参数由调用隐式提供.
4. 类本身也是对象.
5. 内置类型可以作为用户扩展的基类.

###### 名称和对象

1. 别名,多个名称可以绑定到同一个对象.
2. 不可变类型不受影响.
3. 可变对象会因为传递(指针,引用)而实时改变.

###### python作用域和命名空间

1. namespace是一个从名字到对象的映射.大部分命名空间当前都由Python字典实现.
2. 不同命名空间中的名称之间绝对没有关系.
3. 跟在一个点号之后的名称称为属性.
4. 可以使用`del`删除属性.
5. 不同命名空间拥有不同的生存期.
6. 一个作用域是一个命名空间可直接访问的Python程序的文本区域.
7. `nonlocal`语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定.
8. `global`语句可被用来表明特定变量生存于全局作用域并且应当在其中被重新绑定.
9. 重要的是应该意识到作用域是按字面文本来确定的:在一个模块内定义的函数的全局作用域就是该模块的命名空间,无论该函数从什么地方或以什么别名被调用.另一方面,实际的名称搜索是在运行时动态完成的---但是,语言定义在编译时是朝着静态名称解析的方向演化的,因此不要过于依赖动态名称解析!
10. Python的一个特殊之处在于--如果不存在生效的global语句--对名称的赋值总是进入最内层作用域.赋值不会复制数据---它们只是将名称绑定到对象.删除也是如此:语句del x会从局部命名空间的引用中移除对x的绑定.事实上,所有引入新名称的操作都使用局部作用域:特别地,import语句和函数定义会在局部作用域中绑定模块或函数名称.

###### 初探类

###### 类定义语法

1. 类定义与函数定义一样必须被执行才会起作用.
2. 当进入类定义时,将创建一个新的命名空间.
3. 当从结尾正常离开类定义时,将创建一个类对象,并绑定到类名称.

###### 类对象

1. 类对象支持两种操作:属性引用和实例化.
2. 属性引用使用Python中所有属性引用所使用的标准语法:obj.name.有效的属性名称是类对象被创建时存在于类命名空间中的所有名称,obj.func返回的是函数对象.
3. 类的实例化是使用函数表示法,返回一个新的类实例,自动调用 __init__()方法.

###### 实例对象

1. 实例对象唯一操作是属性引用,有两种有效的属性名称:数据属性和方法.
2. 数据属性对应于c++中的数据成员,python中可以动态添加.
3. 方法是从属于对象的函数.obj.func返回一个方法对象.

###### 方法对象

1. 方法的特殊之处在于实例对象会作为函数的第一个参数被传入.
2. 调用一个具有n个参数的方法就相当于调用再多一个参数的对应函数,这个参数值为方法所属实例对象,位置在其他参数之前.
3. 当一个实例的非数据属性被引用时,将搜索实例所属的类.如果名称表示一个属于函数对象的有效类属性,会通过合并打包(指向)实例对象和函数对象到一个抽象对象中的方式来创建一个方法对象:这个抽象对象就是方法对象.当附带参数列表调用方法对象时,将基于实例对象和参数列表构建一个新的参数列表,并使用这个新参数列表调用相应的函数对象.

###### 类变量和实例变量

1. 实例变量用于每个实例的唯一数据,而类变量用于类的所有实例共享的属性和方法.
2. 共享数据可能在涉及mutable对象例如列表和字典的时候导致令人惊讶的结果.

###### 补充说明

1. 数据属性会覆盖掉具有相同名称的方法属性,使用某种规定来最小化冲突发生的几率.
2. 数据属性可以被方法以及一个对象的普通用户(客户端)所引用.换句话说,类不能用于实现纯抽象数据类型.实际上,在Python中没有任何东西能强制隐藏数据---它是完全基于约定的(而在另一方面,用C语言编写的Python实现则可以完全隐藏实现细节,并在必要时控制对象的访问;此特性可以通过用C编写Python扩展来使用.)
3. 客户端应当谨慎地使用数据属性.
4. 在方法内部引用数据属性(或其他方法!)并没有简便方式,不会存在混淆局部变量和实例变量的机会.
5. 方法的第一个参数常常被命名为self.这也不过就是一个约定:self这一名称在Python中绝对没有特殊含义.
6. 任何一个作为类属性的函数都为该类的实例定义了一个相应方法.
7. 方法可以通过使用self参数的方法属性调用其他方法.
8. 方法可以通过与普通函数相同的方式引用全局名称.
9. 每个值都是一个对象,因此具有类(也称为类型),并存储为object.__class__.

###### 继承

1. 基类名称必须定义于包含派生类定义的作用域中.
2. 派生类可能会重载其基类的方法.
3. 在派生类中的重载方法实际上可能想要扩展而非简单地替换同名的基类方法.
4. Python有两个内置函数可被用于继承机制:
   1. 使用`isinstance()`来检查一个实例的类型:isinstance(obj, int)仅会在obj.__class__ 为int或某个派生自int的类时为True.
   2. 使用`issubclass()`来检查类的继承关系:issubclass(bool, int)为True,因为bool是int的子类.但是,issubclass(float, int)为False,因为float不是int的子类.

###### 多重继承

1. 对于多数应用来说,在最简单的情况下,你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的,当层次结构中存在重叠时不会在同一个类中搜索两次.
2. 真实情况比这个更复杂一些:方法解析顺序会动态改变以支持对super()的协同调用.
3. 动态改变顺序是有必要的,因为所有多重继承的情况都会显示出一个或更多的菱形关联(即至少有一个父类可通过多条路径被最底层类所访问).例如,所有类都是继承自object,因此任何多重继承的情况都提供了一条以上的路径可以通向object.为了确保基类不会被访问一次以上,动态算法会用一种特殊方式将搜索顺序线性化,保留每个类所指定的从左至右的顺序,只调用每个父类一次,并且保持单调(即一个类可以被子类化而不影响其父类的优先顺序).

###### 私有变量

1. 大多数Python代码都遵循这样一个约定:带有一个下划线的名称(例如_spam)应该被当作是API的非公共部分(无论它是函数、方法或是数据成员).
2. 由于存在对于类私有成员的有效使用场景(例如避免名称与子类所定义的名称相冲突),因此存在对此种机制的有限支持,称为`名称改写`.任何形式为__spam的标识符(至少带有两个前缀下划线,至多一个后缀下划线)的文本将被替换为_classname__spam,其中classname为去除了前缀下划线的当前类名称.这种改写不考虑标识符的句法位置,只要它出现在类定义内部就会进行.
3. 名称改写有助于让子类重载方法而不破坏类内方法调用.
4. 改写规则的设计主要是为了避免意外冲突;访问或修改被视为私有的变量仍然是可能的.
5. 请注意传递给`exec()`或`eval()`的代码将不会发起调用类的类名视作当前类;这类似于global语句的效果,因此这种效果仅限于同时经过字节码编译的代码.同样的限制也适用于 getattr(),setattr()和delattr(),以及对于 __dict__ 的直接引用.

###### 杂项说明

1. 有时会需要使用类似于Pascal的"record"或C的"struct"这样的数据类型,将一些命名数据项捆绑在一起.这种情况适合定义一个空类.
2. 一段需要特定抽象数据类型的Python代码往往可以被传入一个模拟了该数据类型的方法的类作为替代.
3. 实例方法对象也具有属性:`m.__self__`就是带有m()方法的实例对象,而`m.__func__`则是该方法所对应的函数对象.

###### 迭代器

1. 多数容器对象都可以使用for语句.
2. 迭代器的使用非常普遍并使得Python成为一个统一的整体.在幕后,for语句会调用容器对象中的`iter()`.该函数返回一个定义了`__next__()`方法的迭代器对象,该方法将逐一访问容器中的元素.当元素用尽时,__next__()将引发StopIteration异常来通知终止for循环.你可以使用next()内置函数来调用 __next__() 方法.
3. 为类添加迭代器行为.定义一个 __iter__() 方法来返回一个带有 __next__() 方法的对象.如果类已定义了 __next__(),则 __iter__() 可以简单地返回self.

###### 生成器

1. Generator是一个用于创建迭代器的简单而强大的工具.它们的写法类似标准的函数,但当它们要返回数据时会使用yield语句.每次对生成器调用next()时,它会从上次离开位置恢复执行(会记录上次执行时的数据值).
2. 可以用生成器来完成的操作同样可以用基于类的迭代器来完成.但生成器的写法更为紧凑,因为它会自动创建 __iter__() 和 __next__() 方法.
3. 另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存.
4. 除了会自动创建方法和保存程序状态,当生成器终结时,它们还会自动引发StopIteration.

###### 生成器表达式

1. 某些简单的生成器可以写成简洁的表达式代码,所用语法类似列表推导式,将外层改为圆括号而非方括号.这种表达式被设计用于生成器将立即被外层函数所使用的情况.生成器表达式相比完整的生成器更紧凑但较不灵活,相比等效的列表推导式则更为节省内存.

#### 19-4-1

##### 10标准库简介一

###### 操作系统接口

1. `OS`模块提供了与操作系统交互的函数.
2. 应使用`import os`而不是`from os import *`,避免莫名替换.
3. 内置的`dir()`和`help()`可用作交互式辅助工具,用于处理大型模块.
4. `shutil`提供了日常文件和目录管理的易于使用的高级接口.

###### 文件通配符

* `glob`模块提供了一个在目录中使用通配符搜索创建文件列表的函数.

###### 命令行参数

1. `sys.argv`用来处理命令行参数.
2. `getopt`模块使用Unix中getopt()函数的约定来处理sys.argv.
3. `argparse`模块提供了更强大,更灵活的命令行参数处理.

###### 错误输出重定向和程序终止

1. `sys`模块中stdin,stdout,stderr.
2. 终止脚本的最直接方法是使用`sys.exit()`.

###### 字符串模式匹配

1. `re`模块为高级字符串处理提供正则表达式工具.
2. 只需要简单的功能时,首选字符串方法更加简单.

###### 数学

1. `math`模块提供对浮点数的底层C库函数的访问.
2. `random`模块提供了进行随机选择的工具.
3. `statistics`模块计算数值数据的基本统计属性.

###### 互联网访问

1. `urllib.request`用于从URL检索数据.
2. `smtplib`用于发送邮件.

###### 日期和时间

* `datetime`模块提供了以简单和复杂的方式操作日期和时间的类.虽然支持日期和时间算法,但实现的重点是有效的成员提取以进行输出格式化和操作.该模块还支持可感知时区的对象.

###### 数据压缩

* 常见的数据存档和压缩格式由模块直接提供,包括:`zlib`,`gzip`,`bz2`,`lzma`,`zipfile`和`tarfile`.

###### 性能测量

1. `timeit`模块可以度量运行时间.
2. `profile`和`pstats`提供了用于在较大的代码块中识别时间关键部分的工具.

###### 质量控制

1. `doctest`提供工具用于扫描模块验证程序文档字符串中嵌入的测试.
2. `unittest`模块允许在一个单独的文件中维护更全面的测试集.

###### 包含电池

1. `xmlrpc.client`和`xmlrpc.server`模块用于远程过程调用.
2. `email`包与`smtplib`和`poplib`实际上发送和接收消息不同,电子邮件包具有完整的工具集,用于构建或解码复杂的消息结构(包括附件)以及实现互联网编码和标头协议.
3. `json`包为解析这种流行的数据交换格式提供了强大的支持.
4. `csv`模块支持以逗号分隔值格式直接读取和写入文件,这些格式通常由数据库和电子表格支持.
5. `XML`处理由`xml.etree.ElementTree`,`xml.dom`和`xml.sax`包支持.
6. `sqlite3`模块是SQLite数据库的包装器,提供了一个可以使用稍微非标准的SQL语法更新和访问的持久数据库.
7. 国际化由许多模块支持,包括`gettext`,`locale`和`codecs`包.

##### 11标准库简介二

###### 格式化输出

1. `reprlib`模块提供了一个定制化版本的`repr()`函数,用于缩略显示大型或深层嵌套的容器对象.
2. `pprint`模块提供了更加复杂的打印控制,其输出的内置对象和用户自定义对象能够被解释器直接读取.当输出结果过长而需要折行时,"美化输出机制"会添加换行符和缩进,以更清楚地展示数据结构.
3. `textwrap`模块能够格式化文本段落,以适应给定的屏幕宽度.
4. `locale`模块处理与特定地域文化相关的数据格式.`locale`模块的`format`函数包含一个`grouping`属性,可直接将数字格式化为带有组分隔符的样式.

###### 模板

1. `string`模块包含一个通用的`Template`类,具有适用于最终用户的简化语法.它允许用户在不更改应用逻辑的情况下定制自己的应用.
2. 上述格式化操作是通过占位符实现的,占位符由`$`加上合法的`Python`标识符(只能包含字母、数字和下划线)构成.一旦使用花括号将占位符括起来,就可以在后面直接跟上更多的字母和数字而无需空格分割.`$$`将被转义成单个字符`$`.
3. 如果在字典或关键字参数中未提供某个占位符的值,那么`substitute()`方法将抛出`KeyError`.对于邮件合并类型的应用,用户提供的数据有可能是不完整的,此时使用`safe_substitute()`方法更加合适——如果数据缺失,它会直接将占位符原样保留。
4. `Template`的子类可以自定义定界符.
5. 模板的另一个应用是将程序逻辑与多样的格式化输出细节分离开来.这使得对XML文件、纯文本报表和HTML网络报表使用自定义模板成为可能.

###### 使用二进制数据记录格式

* `struct`模块提供了`pack()`和`unpack()`函数,用于处理不定长度的二进制记录格式.

###### 多线程

1. 线程是一种对于非顺序依赖的多个任务进行解耦的技术.多线程可以提高应用的响应效率,当接收用户输入的同时,保持其他任务在后台运行.一个有关的应用场景是,将I/O和计算运行在两个并行的线程中.
2. 多线程应用面临的主要挑战是,相互协调的多个线程之间需要共享数据或其他资源.为此,`threading`模块提供了多个同步操作原语,包括线程锁、事件、条件变量和信号量.
3. 实现多任务协作的首选方法是将对资源的所有请求集中到一个线程中,然后使用`queue`模块向该线程供应来自其他线程的请求.应用程序使用`Queue`对象进行线程间通信和协调,更易于设计,更易读,更可靠.

###### 日志

1. `logging`模块提供功能齐全且灵活的日志记录系统.在最简单的情况下,日志消息被发送到文件或`sys.stderr`.
2. 默认情况下,informational和debugging消息被压制,输出会发送到标准错误流.其他输出选项包括将消息转发到电子邮件,数据报,套接字或HTTP服务器.新的过滤器可以根据消息优先级选择不同的路由方式:DEBUG,INFO,WARNING,ERROR,和CRITICAL.
3. 日志系统可以直接从Python配置,也可以从用户配置文件加载,以便自定义日志记录而无需更改应用程序.

###### 弱引用

1. Python会自动进行内存管理(对大多数对象进行引用计数并使用`garbage collection`(`gc`模块,垃圾回收器)来清除循环引用).当某个对象的最后一个引用被移除后不久就会释放其所占用的内存.
2. 此方式对大多数应用来说都适用,但偶尔也必须在对象持续被其他对象所使用时跟踪它们.不幸的是,跟踪它们将创建一个会令其永久化的引用.
3. `weakref`模块提供的工具可以不必创建引用就能跟踪对象.当对象不再需要时,它将自动从一个弱引用表中被移除,并为弱引用对象触发一个回调.典型应用包括对创建开销较大的对象进行缓存.

###### 用于操作列表的工具

1. 许多对于数据结构的需求可以通过内置列表类型来满足.但是,有时也会需要具有不同效费比的替代实现.
2. `array`模块提供了一种array()对象,它类似于列表,但只能存储类型一致的数据且存储密集更高.存储为标准Python的int对象通常要占用16个字节.
3. `collections`模块提供了一种`deque()`对象,它类似于列表,但从左端添加和弹出的速度较快,而在中间查找的速度较慢.此种对象适用于实现队列和广度优先树搜索.
4. `bisect`模块具有用于操作排序列表的函数.
5. `heapq`模块提供了基于常规列表来实现堆的函数.最小值的条目总是保持在位置零.这对于需要重复访问最小元素而不希望运行完整列表排序的应用来说非常有用.

###### 十进制浮点运算

1. `decimal`模块提供了一种Decimal数据类型用于十进制浮点运算.相比内置的float二进制浮点实现,该类特别适用于:
   1. 财务应用和其他需要精确十进制表示的用途;
   2. 控制精度;
   3. 控制四舍五入以满足法律或监管要求;
   4. 跟踪有效小数位;
   5. 用户期望结果与手工完成的计算相匹配的应用程序.
2. Decimal表示的结果会保留尾部的零,并根据具有两个有效位的被乘数自动推出四个有效位.Decimal可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题.
3. 精确表示特性使得Decimal类能够执行对于二进制浮点数来说不适用的模运算和相等性检测.
4. `decimal`模块提供了运算所需要的足够精度

    ```py
    getcontext().prec = 36
    Decimal(1) / Decimal(7)
    ```

##### 12虚拟环境和包

> 一个Python安装可能无法满足每个应用程序的要求.应用程序可能需要特定版本的包的支持.

###### 创建虚拟环境

1. 用于创建和管理虚拟环境的模块称为`venv`.venv通常会安装你可用的最新版本的Python.
2. 创建虚拟环境`python3 -m venv tutorial-env`.如果tutorial-env不存在,将创建它.
3. 激活环境

    ```txt
    windows
    tutorial-env\Scripts\activate.bat
    unix
    source tutorial-env/bin/activate
    ```

###### 使用pip管理包

1. `pip search some`搜索包.
2. `pip install requests==2.6.0`安装包.
3. `pip uninstall some`卸载包.
4. `pip show some`显示特定包的信息.
5. `pip list`显示安装的所有包.
6. `pip freeze > requirements.txt`将生成一个类似的已安装包列表,输出使用pip install期望的格式.
7. `pip install -r requirements.txt`批量安装包.

##### 13接下来

1. python标准库
2. 安装python模块
3. python语言参考
4. [python官网](https://www.python.org)
5. [python文档](https://docs.python.org)
6. [pypi](https://pypi.org)
7. [python cookbook](https://code.activestate.com/recipes/langs/python/),重点部分整理在《python cookbook》一书中.
8. [会议和用户组会议相关视频](http://www.pyvideo.org)
9. [scipy项目](https://scipy.org)

##### 14交互式编辑和编辑历史

###### TAB补全和编辑历史

###### 默认交互式解释器的替代品

1. IPYTHON
2. BPYTHON

##### 15浮点算术:争议和限制

1. 浮点数在计算机硬件中表示为以2为基数(二进制)的小数.
2. 大多数的十进制小数都不能精确地表示为二进制小数.
3. 十进制浮点数都只能近似地以二进制浮点数形式储存在计算机中.
4. 浮点数都只能近似地使用二进制小数表示,对应分数的分子使用每8字节的前53位表示,分母则表示为2的幂次.在1/10这个例子中,相应的二进制分数是3602879701896397/2 ** 55,它很接近1/10,但并不是1/10.
5. 在历史上,Python提示符和内置的repr()函数会选择具有17位有效数字的来显示,即0.10000000000000001.从Python 3.1开始,Python(在大多数系统上)现在能够选择这些表示中最短的并简单地显示0.1.
6. 精确十进制`decimal`模块.
7. 有理数算术运算`fractions`模块.
8. `float.as_integer_radio()`转化为分数表示.
9. `floa.hex()`返回计算机中的精确值.
10. `math.fsum()`函数,它有助于减少求和过程中的精度损失.它会在数值被添加到总计值的时候跟踪"丢失的位".

###### 表示性错误

1. `表示性错误`是指某些(其实是大多数)十进制小数无法以二进制(以2为基数的计数制)精确表示这一事实造成的错误.
2. 将0.1表示为`J/2**N`形式的最接近分数,J为恰好包含53个二进制位的整数.
   1. `1/10 ~= J/(2**N)`.
   2. `J~=2**N/10`.
   3. `2**52<= 2**56 //10 <2**53`,所以N取56.
   4. `q, r = divmod(2**56, 10)`,r=6超过10的一半,因此q+1=7205759403792794.
   5. 因此结果为`7205759403792794 / 2**56`>>>`3602879701896397 / 2 ** 55`.

##### 16附录

###### 交互模式

1. 错误处理
   1. 当发生错误时,解释器会打印错误信息和错误堆栈.在交互模式下,将返回到主命令提示符;如果输入内容来自文件,在打印错误堆栈之后,程序会以非零状态退出.
   2. 所有错误信息都会被写入标准错误流;而命令的正常输出则被写入标准输出流.
   3. 将中断字符(通常为Control-C或Delete)键入主要或辅助提示会取消输入并返回主提示符.在执行命令时键入中断引发的`KeyboardInterrupt`异常,可以由try语句处理.
2. 可执行的Python脚本
   1. 在BSD等类Unix系统上,Python脚本可以直接执行,就像shell脚本一样.
   2. 在文件开头第一行添加`#!/usr/bin/env python`.
   3. 在windows系统上直接双击运行.
3. 交互式启动文件
   1. 当以交互方式使用Python时,每次启动解释器时都会执行一些标准命令,这通常很方便.可以通过将名为`PYTHONSTARTUP`的环境变量设置为包含启动命令的文件名来实现.
4. 定制模块
   1. Python提供了两个钩子来让你自定义它:`sitecustomize`和`usercustomize`.
   2. 在site-packages目录下创建一个名`usercustomize.py`的文件,并将所需内容放入其中.它会影响Python的每次启动,除非它以`-s`选项启动,以禁用自动导入.
   3. `sitecustomize`以相同的方式工作,但通常由计算机管理员在全局`site-packages`目录中创建,并在`usercustomize`之前被导入.

### >>>2Python语言参考

#### 19-4-6

##### 1概述

* 对Python编程语言的描述，并不适宜作为教程使用。

###### 其他实现

1. CPython，最早出现并持续维护，以C语言编写。新的语言特性通常在此率先添加。
2. Jython，以 Java 语言编写的 Python 实现。此实现可以作为 Java 应用的一个脚本语言，或者可以用来创建需要 Java 类库支持的应用。
3. Python for .NET，此实现实际上使用了 CPython 实现，但是属于 .NET 托管应用并且可以引入 .NET 类库。
4. IronPython，另一个 .NET 的 Python 实现，与 Python.NET 不同点在于它是生成 IL 的完全 Python 实现，并且将 Python 代码直接编译为 .NET 程序集。
5. PyPy，完全使用 Python 语言编写的 Python 实现。它支持多个其他实现所没有的高级特性，例如非栈式支持和 JIT 编译器等。此项目的目标之一是通过允许方便地修改解释器 (因为它是用 Python 编写的)，鼓励该对语言本身进行试验。

###### 标注

1. 句法和词法解析的描述采用经过改进的 BNF 语法标注。这包含以下定义样式:

    ```py
    name      ::= lc_letter(lc_letter | "_")*
    lc_letter ::= "a"..."z"
    ```

    第一行表示name是一个lc_letter之后跟零个或多个lc_letter和下划线。而一个lc_letter则是任意个“a”至“z”字符。

2. 每条规则的开头是一个名称 (即该规则所定义的名称) 加上 ::=。
    1. 竖线 (|) 被用来分隔可选项；它是此标注中最灵活的操作符。
    2. 星号 (\*) 表示前一项的零次或多次重复；
    3. 加号 (+) 表示一次或多次重复;
    4. 由方括号括起的内容 ([ ]) 表示出现零次或一次 (或者说，这部分内容是可选的)。
    5. \* 和 + 操作符的绑定是最紧密的；圆括号用于分组。
    6. 固定字符串包含在引号内。
    7. 空格的作用仅限于分隔形符。
    8. 每条规则通常为一行；
    9. 有许多个可选项的规则可能会以竖线为界分为多行。
3. 在词法定义中，还额外使用了两个约定:
    1. 由三个点号分隔的两个本义字符表示在指定 (开) 区间范围内的任意单个 ASCII 字符。
    2. 由尖括号 (<...>) 括起来的内容是对于所定义符号的非正式描述；即可以在必要时用来说明 '控制字符' 的意图。
4. 虽然所用的标注方式几乎相同，但是词法定义和句法定义是存在很大区别的: 词法定义作用于输入源中单独的字符，而句法定义则作用于由词法分析所生成的形符流。

---

## 5-黑马python

### ~~>>>15-flask教程{19-3-21}~~

##### 路由模块

* Werkzeug

##### 模板引擎

* jinja2

##### 操作数据库

* Flask-SQLalchemy

##### 表单

* Flask-WTF

##### 扩展命令行

* Flask-script

##### 认证用户状态

* Flask-Login

##### 开发REST API的工具

* Flask-RESTful

##### 集成前端Twitter Bootstrap框架

* Flask-Bootstrap

##### 本地化日期和时间

* Flask-Moment

##### 反向解析

* url_for

##### JSON数据

* jsonify

#### 19-3-20

##### 数据库迁移

* Flask-Migrate

##### 邮箱扩展

* Flask-Mail

##### 模块划分,循环引用,蓝图

1. 为视图函数添加路由器
2. 使用蓝图--Blueprint

#### 19-3-21

##### 单元测试

* unittest
* flask的测试模式
* 数据库测试

##### 部署

* Gunicorn 绿色独角兽

---

### ~~>>>16-微信公众号{19-3-23}~~

#### 19-3-23

##### 微信公众号服务器配置

1. 可以申请公众号的测试号.
2. 配置第三方服务器,返回特定数据用来验证配置.

##### 收发消息,事件

1. XML格式数据通信.
2. 事件响应.

##### 微信网页授权

1. 提供给用户一个URL,包含重定向内容.
2. 用户点击,弹出授权页面.
3. 同意授权后,重定向到第三方服务器.
4. 第三方服务器获取code.
5. 第三方服务器用code访问微信服务器验证.
6. 第三方服务器得到验证之后获取用户信息.
7. 第三方服务器返回网页.

### ~~>>>17-flask项目-爱家租房{19-4-12}~~

1. CloudStudio中`apt update`后安装`mysql-client`和`libmysqlclient-dev`和`redis-server`.
2. pip安装`requirements.txt`和`redis`.
3. 免费数据库`mysql -h db4free.net -P 3306 -umy__sql -p`.
4. 启动redis`sudo /etc/init.d/redis-server start`.
5. 关闭redis.
   1. `CTRL+C`.
   2. `kill pid`.
   3. `redis-cli shutdown`.
   4. `/etc/init.d/redis-server stop`.

#### 19-3-29

##### 前后端分离

1. 前后端不分离,后端提供被数据渲染之后的模板,即完整网页.
2. 前后端分离,后端不再控制前端的效果展示,仅仅提供数据,可以实现接口复用,但不利于SEO.

##### 项目文件目录结构

1. 在单一文件(manage.py)中构建所有依赖工具.
   1. 配置信息.
   2. 数据库.
   3. redis.
   4. 使用flask-session扩展将session保存到redis中.
   5. 使用flask-wtf中的csrfprotrction防护.
2. 依次拆分
   1. 将配置信息拆分(config.py),可以通过继承得到不同的配置,并使用工厂模式根据不同的参数创建不同的app对象.
   2. 创建包`ihome`,在包的`__init__.py`中提供`creat_app`接口,并完成其他相关操作.
      1. 在`ihome`下创建带版本号的包`api_1_0`,在`__init__.py`中创建蓝图,在其中存放视图.
      2. 在`ihome`下创建`static`静态文件.
      3. 在`ihome`下创建`utils`工具.
      4. 在`ihome`下创建`libs`包,存放第三方扩展包.
      5. 在`ihome`下创建`models.py`.
   3. 最终,在`manage.py`中仅仅创建app并提供脚本.

##### 日志功能

* 使用python自带的logging模块以及current_app中的logger全局对象.

#### 19-3-30

##### 数据表设计

1. 以存储空间换查询时间.
2. 多对多通过中间表实现.

##### 日志系统bug

* debug模式下设置日志级别不起作用.

##### 数据库迁移

1. `python manage.py db init`.
2. `python manage.py db migrate -m '说明'`别忘了import models证明一下models的存在.
   1. 迁移时报错SQLAlchemy报错(1193),升级SQLAlchemy或者降级mysql可以解决.
3. `python manage.py db upgrade`.

#### 19-3-31

##### 静态文件接口

1. 提供静态文件接口的蓝图.
2. 自定义正则转换器.
3. flask提供了返回静态文件的方法`current_app.send_static_file()`.

##### csrf防护

1. 浏览器--同源策略.
2. 对比cookie和body中的`csrf_token`.
3. 使用`flask-wtf`中的`csrf`生成`csrf_token`,在静态路由中添加之.

##### 图片验证码

1. 使用`captcha`工具.
2. 保存在redis中.
3. `RESTful`风格接口.

##### 开发流程与接口文档

##### 短信验证

1. 借助`云通讯`的sdk-python.
2. 使用单例模式封装接口.
3. 发送验证码前后端编写.

#### 19-4-3

##### 注册

1. 规定接口；
2. 规定传递的参数。

###### 参数校验

###### 密码加密

* `from werkzeug.security import generate_password_hash`.

###### property装饰器

###### 前端拦截表单提交

1. `e.preventDefault()`拦截表单的自动提交行为；
2. 使用ajax处理。

###### 前端请求头传递csrf_token

##### 登录

1. 接口；
2. 传递的参数。

###### 限制访问次数

1. 使用IP地址（request.remote_addr）。存入redis。
2. redis自动递增函数。

###### 后端检查登录状态接口

###### 后端登出接口

###### 登录验证装饰器

1. g对象保留本次访问的信息；
2. `functools.wraps`保留被装饰函数的信息。

#### 19-4-4

##### 图片服务

1. 扩容
2. 备份
3. 多机存储

###### 搭建文件存储系统

1. FastDFS-快速分布式文件存储系统，电商。
2. HDFS-Hadoop分布式文件系统，多种文件。

###### 第三方服务

1. 七牛云，使用对应的SDK；
2. 对象存储。

###### 前端异步提交

1. 使用`jquery.form.min.js`中的`ajaxSubmit`对表单进行异步提交。

##### 城区信息--缓存

1. 访问频率高，变化频率低；
2. 缓存和数据库一起存。

###### 缓存的同步问题

1. 操作mysql时删除缓存数据；
2. 设置有效期。

##### 前端模板

1. `art-template`.

#### 19-4-6

##### 发布房源

###### 保存房屋基本信息后端

###### 保存房屋图片信息后端

###### 保存房屋信息前端

* JS中的map函数。

#### 19-4-7

##### celery

###### celery模型

1. worker（任务处理者）--- 完整的任务代码。
2. broker（任务队列）：rabbitMQ，redis
3. client（客户端）--- 定义任务（使用装饰器app.task）>> 发布任务（.delay）
4. backend（保存结果数据）

###### celery使用

1. 定义celery对象；
2. 定义任务,使用`@celery_app.task`；
3. 发布任务，`.delay(参数)`
4. 启动celery，保证与客户端在同一目录下启动`celery -A 定义任务的python模块 -l info`。

###### celery目录结构

1. 启动文件`main.py`;
2. 配置文件`config.py`;
3. 任务文件（包），可以自动搜寻异步任务。

###### celery独立的目录使用

* celery可以使用独立的目录，只要保证和客户端目录一致即可。

###### celery接收返回值

1. 客户端处返回异步任务对象；
2. 通过返回的对象的`get()方法`可以接收返回值，但是默认是阻塞态。

#### 19-4-9

##### 房屋管理

###### 展示我的房源

###### 显示主页数据

1. 存入缓存备用;
2. 前端轮播插件`swiper`.

###### 房屋详情数据

1. 判断是否为房东浏览;
2. 大量数据转换,将方法封装到模型类中;
3. 前端获取请求路径中的搜索参数.

#### 19-4-11

##### 房屋列表

> 按照选定的规则进行房屋信息查询.

###### 过滤规则

1. 将数据库比较语句存入过滤器列表中;
2. 魔法方法`__eq__`重写`==`逻辑.

###### 缓存处理

1. 将当前查询条件的结果存入redis中;
2. redis中的`pipline`,是一种管道,一次可以执行多条语句.

##### 订单

###### 时间处理

* datetime时间相减得到时间间隔,用来得到间隔天数.

###### 保存订单

###### 查询订单

###### 接单/拒单

###### 评论

##### 订单支付

###### 支付宝接入流程

###### 手机网站支付流程

#### 19-4-12

##### 订单支付(续)

###### 支付宝密钥与SDK使用

1. 使用rsa非对称加密算法;
   1. openssl生成私钥和公钥.
2. 支付宝官方没有提供python版本的SDK,使用第三方`phthon-alipay-sdk`.

###### 支付宝支付后端接口

###### 获取支付结果修改订单

##### 项目优化

###### csrf_token丢失bug的解决

1. WTF从session
2. 解决方法:清空session时,单独保留`csrf_token`.

###### 数据库优化

1. 表结构设计优化;
    1. 关系型数据库的三范式
        1. 拆的不能再拆;
        2. 只保留主要信息;
        3. 次要信息.
2. 建索引---主键/唯一约束(unique)/索引(key/index)/外键/组合索引
    1. 使用二叉树,二分搜索
    2. 提升查询速度;
    3. 降低增删改效率.
3. sql语句优化
    1. 最左原则;
    2. 不要使用`select *`;
    3. 能使用联合查询,不使用嵌套;
    4. 如有必要,联合查询也不要用;
    5. 外键---保证数据的完整性,删除外键时,使用级联可以连带删除;
    6. 使用分析工具.
4. 缓存
5. 读写分离
    1. 主从热备份
    2. 主(写)从(查)
6. 分库分表
    1. 垂直分表
    2. 垂直分库
    3. 水平分库分表

###### 工作流程

1. email
2. git---gitlab---账号权限---rsa
3. vpn---虚拟私有网络---阿里云-腾讯云-AWS
4. 数据库

### >>>18-通用爬虫模块

#### 19-4-14

##### 爬虫基本概念

###### 课程介绍和概念

1. 动态网页与静态网页;
2. 微指数-微博;
3. 爬虫模拟浏览器行为.

###### 爬虫的分类

1. 通用爬虫
2. 聚焦爬虫

###### markdown介绍

###### robots协议

* 道德层面的协议.

###### HTTP和HTTPS协议

1. HTTP---超文本传输协议,默认端口80;
2. HTTPS---加入SSL(安全套接层),默认端口443;
3. HTTPS更安全,但是性能低.

###### 浏览器发送HTTP请求的过程

1. DNS服务器;
2. 浏览器渲染的页面和爬虫请求的页面不一样.

#### 19-4-19

##### 爬虫基本概念[续]

###### URL和HTTP请求格式

1. URL基本格式:`scheme://host[:port#]/path/…/[?query-string][#anchor]`
    1. scheme：协议(例如：http, https, ftp)
    2. host：服务器的IP地址或者域名
    3. port#：服务器的端口（如果是走协议默认端口，缺省端口80）
    4. path：访问资源的路径
    5. query-string：参数，发送给http服务器的数据
    6. anchor：锚（跳转到网页的指定锚点位置）
2. HTTP请求格式:
    1. 请求行,`请求方法+空格+URL+空格+协议版本+回车换行`;
    2. 请求头部,`头部字段名:值+回车换行*n`;
    3. 空行
    4. 请求数据

###### 字符串类型

1. str
2. bytes

##### requests库

###### 发送请求和获取网页字符串

1. 接口简单;
2. 注意解码.

###### requests发送带参数的请求

* `r = requests.get(url,headers=headers)`.

#### 19-4-20

##### requests库[续]

###### 贴吧爬虫

###### 发送POST请求

* `r = requests.post("http://www.baidu.com/", data = data)`

###### 使用代理

1. 代理分类
    1. 反向代理nginx,浏览器不知道最终服务器的地址.
    2. 正向代理,浏览器知道最终服务器的地址.
2. 作用
    1. 隐藏真实地址;
    2. 避免服务器识别同一客户.

###### 模拟登录的三种方式

1. cookie和session的区别
    1. cookie浏览器,session服务器.
2. 使用requests中封装的session来保存登录信息.
3. 获取登录后的页面的三种方式
    1. 实例化session，使用session发送post请求，在使用他获取登陆后的页面
    2. headers中添加cookie键，值为cookie字符串
    3. 在请求方法中添加cookies参数，接收字典形式的cookie。字典形式的cookie中的键是cookie的name对应的值，值是cookie的value对应的值

##### chrome分析psot和json

###### 寻找post的地址

1. 在form表单中寻找action对应的url地址
    1. post的数据是input标签中name的值作为键，真正的用户名密码作为值的字典，post的url地址就是action对应的url地址
2. 抓包，寻找登录的url地址
    1. 勾选perserve log按钮，防止页面跳转找不到url
    2. 寻找post数据，确定参数
        1. 参数不会变，直接用，比如密码不是动态加密的时候
        2. 参数会变
            1. 参数在当前的响应中
            2. 通过js生成

###### 寻找js和分析js

1. 选择会触发js时间的按钮，点击event listener，找到js的位置
2. 通过chrome中的search all file来搜索url中关键字
3. 添加断点的方式来查看js的操作，通过python来进行同样的操作

###### requests小技巧

1. 将CookieJar转为字典`requests.utils.dict_from_cookiejar(cookiejar)`
2. url编解码`requests.utils.quote`
3. ssl证书验证`verify=True|False`
4. 超时参数`timeout=10`
5. python模块`retrying`,重复多次

---

## 6-牛客网

#### 19-3-22

##### C/C++*50

* C/C++五十题.

#### 19-3-25

##### C/C++*50

* C/C++五十题.

#### 19-3-27

##### C/C++*50

* C/C++五十题.

#### 19-3-28

##### c/c++*50

* C/C++五十题.

#### 19-3-31

##### c/c++*50

* C/C++五十题.

---

## ~~7-WTFPython{19-4-7}~~

#### 19-3-21

##### section-大脑运动

###### 微妙的字符串驻留

###### python字典键覆盖

###### try语句块的return

###### Python会将相同的内存地址分配给第二个对象

###### for语句每次都会重新赋值

###### 执行时机差异

###### is和==,-5~256已经分配

###### 引用相同对象

###### 闭包函数与循环变量绑定

###### is not是一个二元运算符

###### 以外的逗号

###### 字符串末尾的反斜杠

###### 运算符的优先级会影响表达式的求值顺序

###### 三引号

###### 不存在的午夜?

###### 布尔是int的子类

###### 类属性和实例属性

###### 生成器与list

###### tuple也可以改变

###### try语句块在except子句的末尾清除该异常

###### 真与假(python2)

###### 原地修改没有返回值

###### 子类

###### python字典键转换

###### 赋值语句表达式列表,循环赋值

#### 19-3-28

##### section-外表是靠不住的

###### 即使外表和英文字母一样,但并不一样

###### 内存空间被释放后重新分配相同地址

###### 不要混用制表符和空格

#### 19-4-7

##### section-小心地雷

###### 不支持迭代字典时修改它，字典自动扩容

###### del引用计数减1

###### 迭代列表时删除元素

###### for循环，循环变量泄露

###### 默认的可变参数只绑定一次

###### 捕获异常

###### +=与+不同

###### 修改外部作用域变量，global

###### 链式操作

###### 类定义中嵌套的作用域忽略类作用域的名称解析

###### 元组的逗号

##### section-隐藏的宝藏

###### antigravity模块是Python开发人员发布的少数复活节彩蛋之一

###### python没有goto，goto愚人节彩蛋

###### braces，使用大括号的复活节彩蛋

###### ！=和<>。愚人节彩蛋

###### python之禅，复活节彩蛋

###### 循环，异常中的else子句

###### 无穷大infinity的哈希值是 10⁵ x π

###### 类内双下划线名称修饰

##### section-杂项

###### +=更快

###### 字符串拼接 +/format/%/join

###### inf和nan，无穷大和非数字

###### 小知识点

1. join是一个字符串操作而不是一个列表操作；
2. ++操作符实际是两个+；
3. Python使用2个字节存储函数中的本地变量；
4. 全局解释器锁；
5. 列表切片越界不报错；
6. str.count('').

---

## 8-电影

#### 19-3-23

##### 大黄蜂

#### 19-4-3

##### 海王

#### 19-4-5

##### 飞驰人生

##### 神探蒲松龄

---

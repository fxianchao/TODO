- [python官方文档](#python官方文档)
  - [~~>>>1入门教程{19-4-1}~~](#1入门教程19-4-1)
    - [19-3-24](#19-3-24)
      - [1课前甜点](#1课前甜点)
      - [2使用python解释器](#2使用python解释器)
        - [调用解释器](#调用解释器)
        - [解释器的运行环境](#解释器的运行环境)
      - [3python的非正式介绍](#3python的非正式介绍)
        - [作为计算器使用](#作为计算器使用)
        - [走向编程的第一步](#走向编程的第一步)
      - [4其他流程控制工具](#4其他流程控制工具)
        - [if语句](#if语句)
        - [for语句](#for语句)
        - [range()函数](#range函数)
        - [break和continue语句,以及循环中的else子句](#break和continue语句以及循环中的else子句)
        - [pass语句](#pass语句)
        - [定义函数](#定义函数)
        - [函数定义的更多形式](#函数定义的更多形式)
        - [小插曲:编码风格](#小插曲编码风格)
      - [5数据结构](#5数据结构)
        - [列表的更多特性](#列表的更多特性)
        - [列表作为栈使用](#列表作为栈使用)
        - [列表作为队列使用](#列表作为队列使用)
        - [列表推导式](#列表推导式)
        - [嵌套的列表推导式](#嵌套的列表推导式)
        - [del语句](#del语句)
        - [元组和序列](#元组和序列)
        - [集合](#集合)
        - [字典](#字典)
        - [循环的技巧](#循环的技巧)
        - [深入条件控制](#深入条件控制)
        - [序列和其他类型的比较](#序列和其他类型的比较)
      - [6模块](#6模块)
        - [有关模块的更多信息](#有关模块的更多信息)
        - [以脚本的方式执行模块](#以脚本的方式执行模块)
        - [模块搜索路径](#模块搜索路径)
        - ["编译过的"Python文件](#编译过的Python文件)
        - [标准模块](#标准模块)
        - [dir()函数](#dir函数)
        - [包](#包)
        - [从包中导入*](#从包中导入)
        - [子包参考](#子包参考)
        - [多个目录中的包](#多个目录中的包)
    - [19-3-25](#19-3-25)
      - [7输入输出](#7输入输出)
        - [更漂亮的输出格式](#更漂亮的输出格式)
        - [格式化字符串字面值(f-字符串)](#格式化字符串字面值f-字符串)
        - [字符串的格式化方法](#字符串的格式化方法)
        - [手动格式化字符串](#手动格式化字符串)
        - [旧的字符串格式化方法](#旧的字符串格式化方法)
        - [读写文件](#读写文件)
        - [文件对象的方法](#文件对象的方法)
        - [使用JSON保存结构化数据](#使用JSON保存结构化数据)
    - [19-3-27](#19-3-27)
      - [8错误和异常](#8错误和异常)
        - [语法错误(解析错误)](#语法错误解析错误)
        - [异常](#异常)
        - [处理异常](#处理异常)
        - [抛出异常](#抛出异常)
        - [用户自定义异常](#用户自定义异常)
        - [定义清理操作](#定义清理操作)
        - [预定义的清理操作](#预定义的清理操作)
    - [19-3-28](#19-3-28)
      - [9类](#9类)
        - [名称和对象](#名称和对象)
        - [python作用域和命名空间](#python作用域和命名空间)
        - [初探类](#初探类)
        - [类定义语法](#类定义语法)
        - [类对象](#类对象)
        - [实例对象](#实例对象)
        - [方法对象](#方法对象)
        - [类变量和实例变量](#类变量和实例变量)
        - [补充说明](#补充说明)
        - [继承](#继承)
        - [多重继承](#多重继承)
        - [私有变量](#私有变量)
        - [杂项说明](#杂项说明)
        - [迭代器](#迭代器)
        - [生成器](#生成器)
        - [生成器表达式](#生成器表达式)
    - [19-4-1](#19-4-1)
      - [10标准库简介一](#10标准库简介一)
        - [操作系统接口](#操作系统接口)
        - [文件通配符](#文件通配符)
        - [命令行参数](#命令行参数)
        - [错误输出重定向和程序终止](#错误输出重定向和程序终止)
        - [字符串模式匹配](#字符串模式匹配)
        - [数学](#数学)
        - [互联网访问](#互联网访问)
        - [日期和时间](#日期和时间)
        - [数据压缩](#数据压缩)
        - [性能测量](#性能测量)
        - [质量控制](#质量控制)
        - [包含电池](#包含电池)
      - [11标准库简介二](#11标准库简介二)
        - [格式化输出](#格式化输出)
        - [模板](#模板)
        - [使用二进制数据记录格式](#使用二进制数据记录格式)
        - [多线程](#多线程)
        - [日志](#日志)
        - [弱引用](#弱引用)
        - [用于操作列表的工具](#用于操作列表的工具)
        - [十进制浮点运算](#十进制浮点运算)
      - [12虚拟环境和包](#12虚拟环境和包)
        - [创建虚拟环境](#创建虚拟环境)
        - [使用pip管理包](#使用pip管理包)
      - [13接下来](#13接下来)
      - [14交互式编辑和编辑历史](#14交互式编辑和编辑历史)
        - [TAB补全和编辑历史](#TAB补全和编辑历史)
        - [默认交互式解释器的替代品](#默认交互式解释器的替代品)
      - [15浮点算术:争议和限制](#15浮点算术争议和限制)
        - [表示性错误](#表示性错误)
      - [16附录](#16附录)
        - [交互模式](#交互模式)
  - [>>>2Python语言参考](#2Python语言参考)
    - [19-4-6](#19-4-6)
      - [1概述](#1概述)
        - [其他实现](#其他实现)
        - [标注](#标注)

---

# python官方文档

## ~~>>>1入门教程{19-4-1}~~

### 19-3-24

#### 1课前甜点

#### 2使用python解释器

##### 调用解释器

1. 传入参数
2. 交互模式

##### 解释器的运行环境

* 源文件的字符编码
  1. `# -*- coding:encoding -*-`.
  2. unix

      ```shell
      #!/usr/bin/env python3
      # -*- coding:utf-8 -*-
      ```

#### 3python的非正式介绍

##### 作为计算器使用

1. 数字
2. 字符串
3. 列表

##### 走向编程的第一步

1. 循环赋值
2. while语句
3. 缩进
4. print()函数

#### 4其他流程控制工具

##### if语句

* elif
* else

##### for语句

1. 一个迭代器.
2. 对任意序列进行迭代.
3. 修改需要使用副本.

##### range()函数

1. 可迭代的对象.
2. enumerate()枚举.

##### break和continue语句,以及循环中的else子句

* 循环语句可以带一个`else`子句,没有break跳出时执行该子句.

##### pass语句

1. 最小类
2. 占位符

##### 定义函数

1. 文档字符串
2. 本地作用域
3. 全局变量不能在函数中赋值,使用`global`例外.
4. 参数按照引用传递.

##### 函数定义的更多形式

1. 参数默认值.
   1. 默认值是在定义过程中在函数定义处计算的,只会计算一次,传递可变对象时会共享一个,尤为重要.
2. 关键字参数
   1. 关键字参数必须跟随在位置参数的后面.
3. 任意的参数列表
4. 解包参数列表
5. lambda表达式
6. 文档字符串
   1. 第一行简洁描述对象目的,以大写字母开头,句点结尾.
   2. 多行时第二行为空白.
7. 函数标注
   1. 元数据信息
   2. 函数标注以字典的形式存放在函数的`__annotations__`中.
   3. 形式为在形参名称后加上冒号,后跟一个表达式;返回值标注的形式是加上一个`->`,后跟一个表达式.

##### 小插曲:编码风格

1. 使用4个空格缩进,不使用制表符.
2. 换行.
3. 使用空行分隔函数和类以及较大的代码块.
4. 注释单独放一行.
5. 使用文档字符串.
6. 运算符前后和逗号后使用空格.
7. 类使用大驼峰命名,函数和方法使用下划线分割小写字符命名.

#### 5数据结构

##### 列表的更多特性

1. list.append(x)
2. list.extend(iterable)
3. list.insert(i, x)
4. list.remove(x)
5. list.pop([i])
6. list.clear()
7. list.index(x[start,[,end]])
8. list.count(x)
9. list.sort(key=None, reverse=False)
10. list.reverse()
11. list.copy()

##### 列表作为栈使用

##### 列表作为队列使用

##### 列表推导式

##### 嵌套的列表推导式

##### del语句

##### 元组和序列

##### 集合

##### 字典

1. 键值对
2. list(dict)返回键的列表
3. 字典推导式

##### 循环的技巧

1. dict.items()
2. enumerate(list)
3. zip(list1,list2)
4. 逆序reversed(list)
5. 排序sorted(list)

##### 深入条件控制

1. in / not in
2. is / is not
3. **比较操作符可以传递`a < b == c`会检验`a小于b并且b等于c`.**
4. and / or / not
5. python赋值操作不能发生在表达式内部.

##### 序列和其他类型的比较

1. 按照字典序依次比较.
2. 对于不同类型,只要提供了合适的比较方法即可.

#### 6模块

1. 编写脚本.
2. 模块名可以通过全局变量`__name__`获得.

##### 有关模块的更多信息

1. 可执行语句仅在第一次被导入时才执行.
2. 私有作用域.
3. `from module import some1, some2 [as aaa]`
4. `from module import *`导入所有非下划线开头的名称.
5. 需要重新导入模块时

    ```py
    import importlib
    importlib.reload(modulename)
    ```

##### 以脚本的方式执行模块

1. `pythom mudule.py <arguments>`,此时`__name__`被赋值为`__main__`.
2. `if __name__ == __main__:`

##### 模块搜索路径

1. 首先寻找具有该名称的内置模块.
2. 如果没有找到,会从`sys.path`变量给出的目录列表里寻找.
   1. 包含输入脚本的目录(或者没指定文件时的当前目录).
   2. `PYTHONPATH`一个包含目录名称的列表.
   3. 取决于安装的默认位置.
3. 初始化后,python程序可以更改`sys.path`.当前目录被放在搜索目录的开头处,在标准库路径之前.

##### "编译过的"Python文件

1. 为了加快模块载入,python在`__pychche__`目录中缓存每个模块的编译后版本,名字为`module.version.pyc`.
2. 编译的文件与平台无关.
3. 在两种情况下,不会检查缓存
   1. 从命令行载入的模块直接编译且不会存储编译结果.
   2. 没有源模块时不会检查缓存.
4. 可以有无源文件发行版本.
5. 可以控制编译文件的大小.
6. 运行速度不会快,仅仅提高了载入的速度.
7. `compileall`模块可以为一个目录下的所有文件创建`.pyc`文件.

##### 标准模块

* python自带标准模块库
   1. 取决于底层平台.
   2. 模块`sys`被内嵌到解释器中,变量`sys.ps1`和`sys.ps2`定义用作主要和辅助提示的字符串.仅在交互模式下才被定义.
   3. `sys.path`是一个字符串列表,用于确定解释器的模块搜索路径.

##### dir()函数

1. 内置函数`dir()`用于查找模块定义的名称,返回一个排序过的字符串列表.
2. 如果没有参数,返回当前定义的名称.
3. 不会列出内置函数和变量的名称.如果需要,可以使用`dir(builtins)`.

##### 包

1. 包是一种通过用"带点号的模块名"来构造Python模块命名空间的方法.
2. 模块集合,避免名称重复.
3. 为了让Python将目录当做包,目录中必须包含`__init__.py`文件,可以做初始化工作.

##### 从包中导入*

1. 不推荐使用.
2. 包的显式索引,在包的`__init__.py`中定义一个`__all__`的列表,可以显式指明应该道路的模块名.

##### 子包参考

1. 当包被构造成子包时,你可以使用绝对导入来引用兄弟包的子模块.
2. 相对导入是基于当前模块的名称进行导入的.由于主模块的名称总是"__main__",因此用作Python应用程序主模块的模块必须始终使用绝对导入.

##### 多个目录中的包

1. 包支持另一个特殊属性`__path__`.它被初始化为一个列表,其中包含在执行该文件中的代码之前保存包的文件`__init__.py`的目录的名称.这个变量可以修改;这样做会影响将来对包中包含的模块和子包的搜索.
2. 虽然通常不需要此功能,但它可用于扩展程序包中的模块集.

### 19-3-25

#### 7输入输出

##### 更漂亮的输出格式

1. 格式化字符串字面值.`f"string {变量1} {变量2}"`.
2. 字符串的`str.format()`.
3. `repr()和str()`
   1. `str()`返回人类可读的表示
   2. `repr()`生成解释器可读的表示
   3. 多数时候返回值一样,一种特殊情况为字符串

##### 格式化字符串字面值(f-字符串)

1. 在字符串前加上f和F并将表达式写成{expression}来在字符串中包含Python表达式的值.
2. 可选的格式说明符可以跟在表达式后面.
3. 在':'后传递一个整数可以让该字段成为最小字符宽度.
4. 其他的修饰符可用于在格式化之前转化值.'!a'应用ascii(),'!s'应用str(),还有'!r'应用repr().

##### 字符串的格式化方法

1. 花括号和其中的字符(称为格式字段)将替换为传递给`str.format()`方法的对象.花括号中的数字可用来表示传递给`str.format()`方法的对象的位置.
2. 如果在`str.format()`方法中使用关键字参数,则使用参数的名称引用它们的值.
3. 位置和关键字参数可以任意组合.
4. 可以直接传递字典参数,使用`[]`或者`**`.
5. 在与内置函数`vars()`结合使用时非常有用,它会返回包含所有局部变量的字典.

##### 手动格式化字符串

1. `str.rjust()`填充空格.
2. `str.ljust()`.
3. `str.center()`.
4. `str.zfill()`在字符串左边填充0,可以识别正负号.

##### 旧的字符串格式化方法

* `%`操作符用作字符串格式化.

##### 读写文件

1. `open(filename, mode)`,返回`fiel object`.
2. 读,写,追加,二进制.
3. 在文本模式下读取时,会转换行结束符(unix下`\n`,windows下`\r\n`),会破坏二进制文件格式.
4. 最好使用`with`,不适用python要自己`close`.

##### 文件对象的方法

1. `f.read(size)`
2. `f.readline()`换行符在字符串的末尾.
3. 循环遍历文件对象,`for line in f:`
4. `list(f)`或`f.readlines()`列表形式.
5. `f.write(string)`返回写入的字符数,写入字符串或者字节对象.
6. `f.tell()`返回文件对象在文件中的位置.
7. `f.seek(offset, from_what)`调整文件对象的位置.
8. 在文本文件(那些在模式字符串中没有`b`的打开的文件)中,只允许相对于文件开头搜索(使用`seek(0, 2)`搜索到文件末尾是个例外)并且唯一有效的offset值是那些能从`f.tell()`中返回的或者是零.其他offset值都会产生未定义的行为.

##### 使用JSON保存结构化数据

1. `json.dumps(object)`返回json字符串.
2. `json.loads(string)`返回被封装的对象.
3. `json`可以处理列表和字典,但是无法直接序列化任意类.
4. `pickle`协议允许对任意python对象进行序列化,为python特有,默认情况下不安全,反序列化时可以执行任意代码.

### 19-3-27

#### 8错误和异常

* 语法错误和异常.

##### 语法错误(解析错误)

* `invalid syntax`,文件名和行号以及一个箭头.

##### 异常

1. 异常类型,异常信息.
2. 标准的异常类型是内置的标识符(不是保留关键字).
3. 源代码行的堆栈回溯.

##### 处理异常

1. 首先,执行try子句(try和except关键字之间的(多行)语句).
2. 如果没有异常发生,则跳过except子句并完成try语句的执行.如果在执行try子句时发生了异常,则跳过该子句中剩下的部分.然后,如果异常的类型和except关键字后面的异常匹配,则执行except子句,然后继续执行try语句之后的代码.
3. 如果发生的异常和except子句中指定的异常不匹配,则将其传递到外部的try语句中;如果没有找到处理程序,则它是一个`未处理异常`,执行将停止并显示如上所示的消息.
4. 一个try语句可以有多个ecxept子句.
5. 一个except子句可以将多个异常命名为带括号的元组`except (RuntimeError, TypeErroe, NameErroe)`.
6. except子句匹配,派生类在上面,基类在下面,通用的在最下面.
7. except子句可以重新引发异常.
8. 有一个可选的else子句,不引发异常时执行.
9. 发生异常时,它可能具有关联值,也称为异常参数.参数的存在和类型取决于异常类型.
10. except子句可以在异常名称后面指定一个变量.这个变量和一个异常实例绑定,它的参数存储在`instance.args`中.为了方便起见,异常实例定义了`__str__()`,因此可以直接打印参数而无需引用`.args`.也可以在抛出之前首先实例化异常,并根据需要向其添加任何属性.
11. 如果异常有参数,则它们将作为未处理异常的消息的最后一部分('详细信息')打印.
12. 异常处理程序不仅处理try子句中遇到的异常,还处理try子句中调用(即使是间接地)的函数内部发生的异常.

##### 抛出异常

1. raise语句允许程序员强制发生指定的异常.
2. raise唯一的参数就是要抛出的异常.

##### 用户自定义异常

1. 程序可以通过创建新的异常类来命名它们自己的异常,继承自`Exception`.

##### 定义清理操作

1. try语句有另一个可选子句finally,用于定义必须在所有情况下执行的清理操作.
2. finally一定会执行,对于释放外部资源非常有用.

##### 预定义的清理操作

* `with`语句允许像文件这样的对象能够以一种确保它们得到及时和正确的清理的方式使用.

### 19-3-28

#### 9类

1. 多个基类,多继承.
2. 类成员通常都是public(除了私有变量),所有成员函数都是virtual.
3. 没有用于从其方法引用对象成员的简写:方法函数使用表示对象的显式第一个参数声明,该参数由调用隐式提供.
4. 类本身也是对象.
5. 内置类型可以作为用户扩展的基类.

##### 名称和对象

1. 别名,多个名称可以绑定到同一个对象.
2. 不可变类型不受影响.
3. 可变对象会因为传递(指针,引用)而实时改变.

##### python作用域和命名空间

1. namespace是一个从名字到对象的映射.大部分命名空间当前都由Python字典实现.
2. 不同命名空间中的名称之间绝对没有关系.
3. 跟在一个点号之后的名称称为属性.
4. 可以使用`del`删除属性.
5. 不同命名空间拥有不同的生存期.
6. 一个作用域是一个命名空间可直接访问的Python程序的文本区域.
7. `nonlocal`语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定.
8. `global`语句可被用来表明特定变量生存于全局作用域并且应当在其中被重新绑定.
9. 重要的是应该意识到作用域是按字面文本来确定的:在一个模块内定义的函数的全局作用域就是该模块的命名空间,无论该函数从什么地方或以什么别名被调用.另一方面,实际的名称搜索是在运行时动态完成的---但是,语言定义在编译时是朝着静态名称解析的方向演化的,因此不要过于依赖动态名称解析!
10. Python的一个特殊之处在于--如果不存在生效的global语句--对名称的赋值总是进入最内层作用域.赋值不会复制数据---它们只是将名称绑定到对象.删除也是如此:语句del x会从局部命名空间的引用中移除对x的绑定.事实上,所有引入新名称的操作都使用局部作用域:特别地,import语句和函数定义会在局部作用域中绑定模块或函数名称.

##### 初探类

##### 类定义语法

1. 类定义与函数定义一样必须被执行才会起作用.
2. 当进入类定义时,将创建一个新的命名空间.
3. 当从结尾正常离开类定义时,将创建一个类对象,并绑定到类名称.

##### 类对象

1. 类对象支持两种操作:属性引用和实例化.
2. 属性引用使用Python中所有属性引用所使用的标准语法:obj.name.有效的属性名称是类对象被创建时存在于类命名空间中的所有名称,obj.func返回的是函数对象.
3. 类的实例化是使用函数表示法,返回一个新的类实例,自动调用 __init__()方法.

##### 实例对象

1. 实例对象唯一操作是属性引用,有两种有效的属性名称:数据属性和方法.
2. 数据属性对应于c++中的数据成员,python中可以动态添加.
3. 方法是从属于对象的函数.obj.func返回一个方法对象.

##### 方法对象

1. 方法的特殊之处在于实例对象会作为函数的第一个参数被传入.
2. 调用一个具有n个参数的方法就相当于调用再多一个参数的对应函数,这个参数值为方法所属实例对象,位置在其他参数之前.
3. 当一个实例的非数据属性被引用时,将搜索实例所属的类.如果名称表示一个属于函数对象的有效类属性,会通过合并打包(指向)实例对象和函数对象到一个抽象对象中的方式来创建一个方法对象:这个抽象对象就是方法对象.当附带参数列表调用方法对象时,将基于实例对象和参数列表构建一个新的参数列表,并使用这个新参数列表调用相应的函数对象.

##### 类变量和实例变量

1. 实例变量用于每个实例的唯一数据,而类变量用于类的所有实例共享的属性和方法.
2. 共享数据可能在涉及mutable对象例如列表和字典的时候导致令人惊讶的结果.

##### 补充说明

1. 数据属性会覆盖掉具有相同名称的方法属性,使用某种规定来最小化冲突发生的几率.
2. 数据属性可以被方法以及一个对象的普通用户(客户端)所引用.换句话说,类不能用于实现纯抽象数据类型.实际上,在Python中没有任何东西能强制隐藏数据---它是完全基于约定的(而在另一方面,用C语言编写的Python实现则可以完全隐藏实现细节,并在必要时控制对象的访问;此特性可以通过用C编写Python扩展来使用.)
3. 客户端应当谨慎地使用数据属性.
4. 在方法内部引用数据属性(或其他方法!)并没有简便方式,不会存在混淆局部变量和实例变量的机会.
5. 方法的第一个参数常常被命名为self.这也不过就是一个约定:self这一名称在Python中绝对没有特殊含义.
6. 任何一个作为类属性的函数都为该类的实例定义了一个相应方法.
7. 方法可以通过使用self参数的方法属性调用其他方法.
8. 方法可以通过与普通函数相同的方式引用全局名称.
9. 每个值都是一个对象,因此具有类(也称为类型),并存储为object.__class__.

##### 继承

1. 基类名称必须定义于包含派生类定义的作用域中.
2. 派生类可能会重载其基类的方法.
3. 在派生类中的重载方法实际上可能想要扩展而非简单地替换同名的基类方法.
4. Python有两个内置函数可被用于继承机制:
   1. 使用`isinstance()`来检查一个实例的类型:isinstance(obj, int)仅会在obj.__class__ 为int或某个派生自int的类时为True.
   2. 使用`issubclass()`来检查类的继承关系:issubclass(bool, int)为True,因为bool是int的子类.但是,issubclass(float, int)为False,因为float不是int的子类.

##### 多重继承

1. 对于多数应用来说,在最简单的情况下,你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的,当层次结构中存在重叠时不会在同一个类中搜索两次.
2. 真实情况比这个更复杂一些:方法解析顺序会动态改变以支持对super()的协同调用.
3. 动态改变顺序是有必要的,因为所有多重继承的情况都会显示出一个或更多的菱形关联(即至少有一个父类可通过多条路径被最底层类所访问).例如,所有类都是继承自object,因此任何多重继承的情况都提供了一条以上的路径可以通向object.为了确保基类不会被访问一次以上,动态算法会用一种特殊方式将搜索顺序线性化,保留每个类所指定的从左至右的顺序,只调用每个父类一次,并且保持单调(即一个类可以被子类化而不影响其父类的优先顺序).

##### 私有变量

1. 大多数Python代码都遵循这样一个约定:带有一个下划线的名称(例如_spam)应该被当作是API的非公共部分(无论它是函数、方法或是数据成员).
2. 由于存在对于类私有成员的有效使用场景(例如避免名称与子类所定义的名称相冲突),因此存在对此种机制的有限支持,称为`名称改写`.任何形式为__spam的标识符(至少带有两个前缀下划线,至多一个后缀下划线)的文本将被替换为_classname__spam,其中classname为去除了前缀下划线的当前类名称.这种改写不考虑标识符的句法位置,只要它出现在类定义内部就会进行.
3. 名称改写有助于让子类重载方法而不破坏类内方法调用.
4. 改写规则的设计主要是为了避免意外冲突;访问或修改被视为私有的变量仍然是可能的.
5. 请注意传递给`exec()`或`eval()`的代码将不会发起调用类的类名视作当前类;这类似于global语句的效果,因此这种效果仅限于同时经过字节码编译的代码.同样的限制也适用于 getattr(),setattr()和delattr(),以及对于 __dict__ 的直接引用.

##### 杂项说明

1. 有时会需要使用类似于Pascal的"record"或C的"struct"这样的数据类型,将一些命名数据项捆绑在一起.这种情况适合定义一个空类.
2. 一段需要特定抽象数据类型的Python代码往往可以被传入一个模拟了该数据类型的方法的类作为替代.
3. 实例方法对象也具有属性:`m.__self__`就是带有m()方法的实例对象,而`m.__func__`则是该方法所对应的函数对象.

##### 迭代器

1. 多数容器对象都可以使用for语句.
2. 迭代器的使用非常普遍并使得Python成为一个统一的整体.在幕后,for语句会调用容器对象中的`iter()`.该函数返回一个定义了`__next__()`方法的迭代器对象,该方法将逐一访问容器中的元素.当元素用尽时,__next__()将引发StopIteration异常来通知终止for循环.你可以使用next()内置函数来调用 __next__() 方法.
3. 为类添加迭代器行为.定义一个 __iter__() 方法来返回一个带有 __next__() 方法的对象.如果类已定义了 __next__(),则 __iter__() 可以简单地返回self.

##### 生成器

1. Generator是一个用于创建迭代器的简单而强大的工具.它们的写法类似标准的函数,但当它们要返回数据时会使用yield语句.每次对生成器调用next()时,它会从上次离开位置恢复执行(会记录上次执行时的数据值).
2. 可以用生成器来完成的操作同样可以用基于类的迭代器来完成.但生成器的写法更为紧凑,因为它会自动创建 __iter__() 和 __next__() 方法.
3. 另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存.
4. 除了会自动创建方法和保存程序状态,当生成器终结时,它们还会自动引发StopIteration.

##### 生成器表达式

1. 某些简单的生成器可以写成简洁的表达式代码,所用语法类似列表推导式,将外层改为圆括号而非方括号.这种表达式被设计用于生成器将立即被外层函数所使用的情况.生成器表达式相比完整的生成器更紧凑但较不灵活,相比等效的列表推导式则更为节省内存.

### 19-4-1

#### 10标准库简介一

##### 操作系统接口

1. `OS`模块提供了与操作系统交互的函数.
2. 应使用`import os`而不是`from os import *`,避免莫名替换.
3. 内置的`dir()`和`help()`可用作交互式辅助工具,用于处理大型模块.
4. `shutil`提供了日常文件和目录管理的易于使用的高级接口.

##### 文件通配符

* `glob`模块提供了一个在目录中使用通配符搜索创建文件列表的函数.

##### 命令行参数

1. `sys.argv`用来处理命令行参数.
2. `getopt`模块使用Unix中getopt()函数的约定来处理sys.argv.
3. `argparse`模块提供了更强大,更灵活的命令行参数处理.

##### 错误输出重定向和程序终止

1. `sys`模块中stdin,stdout,stderr.
2. 终止脚本的最直接方法是使用`sys.exit()`.

##### 字符串模式匹配

1. `re`模块为高级字符串处理提供正则表达式工具.
2. 只需要简单的功能时,首选字符串方法更加简单.

##### 数学

1. `math`模块提供对浮点数的底层C库函数的访问.
2. `random`模块提供了进行随机选择的工具.
3. `statistics`模块计算数值数据的基本统计属性.

##### 互联网访问

1. `urllib.request`用于从URL检索数据.
2. `smtplib`用于发送邮件.

##### 日期和时间

* `datetime`模块提供了以简单和复杂的方式操作日期和时间的类.虽然支持日期和时间算法,但实现的重点是有效的成员提取以进行输出格式化和操作.该模块还支持可感知时区的对象.

##### 数据压缩

* 常见的数据存档和压缩格式由模块直接提供,包括:`zlib`,`gzip`,`bz2`,`lzma`,`zipfile`和`tarfile`.

##### 性能测量

1. `timeit`模块可以度量运行时间.
2. `profile`和`pstats`提供了用于在较大的代码块中识别时间关键部分的工具.

##### 质量控制

1. `doctest`提供工具用于扫描模块验证程序文档字符串中嵌入的测试.
2. `unittest`模块允许在一个单独的文件中维护更全面的测试集.

##### 包含电池

1. `xmlrpc.client`和`xmlrpc.server`模块用于远程过程调用.
2. `email`包与`smtplib`和`poplib`实际上发送和接收消息不同,电子邮件包具有完整的工具集,用于构建或解码复杂的消息结构(包括附件)以及实现互联网编码和标头协议.
3. `json`包为解析这种流行的数据交换格式提供了强大的支持.
4. `csv`模块支持以逗号分隔值格式直接读取和写入文件,这些格式通常由数据库和电子表格支持.
5. `XML`处理由`xml.etree.ElementTree`,`xml.dom`和`xml.sax`包支持.
6. `sqlite3`模块是SQLite数据库的包装器,提供了一个可以使用稍微非标准的SQL语法更新和访问的持久数据库.
7. 国际化由许多模块支持,包括`gettext`,`locale`和`codecs`包.

#### 11标准库简介二

##### 格式化输出

1. `reprlib`模块提供了一个定制化版本的`repr()`函数,用于缩略显示大型或深层嵌套的容器对象.
2. `pprint`模块提供了更加复杂的打印控制,其输出的内置对象和用户自定义对象能够被解释器直接读取.当输出结果过长而需要折行时,"美化输出机制"会添加换行符和缩进,以更清楚地展示数据结构.
3. `textwrap`模块能够格式化文本段落,以适应给定的屏幕宽度.
4. `locale`模块处理与特定地域文化相关的数据格式.`locale`模块的`format`函数包含一个`grouping`属性,可直接将数字格式化为带有组分隔符的样式.

##### 模板

1. `string`模块包含一个通用的`Template`类,具有适用于最终用户的简化语法.它允许用户在不更改应用逻辑的情况下定制自己的应用.
2. 上述格式化操作是通过占位符实现的,占位符由`$`加上合法的`Python`标识符(只能包含字母、数字和下划线)构成.一旦使用花括号将占位符括起来,就可以在后面直接跟上更多的字母和数字而无需空格分割.`$$`将被转义成单个字符`$`.
3. 如果在字典或关键字参数中未提供某个占位符的值,那么`substitute()`方法将抛出`KeyError`.对于邮件合并类型的应用,用户提供的数据有可能是不完整的,此时使用`safe_substitute()`方法更加合适——如果数据缺失,它会直接将占位符原样保留.
4. `Template`的子类可以自定义定界符.
5. 模板的另一个应用是将程序逻辑与多样的格式化输出细节分离开来.这使得对XML文件、纯文本报表和HTML网络报表使用自定义模板成为可能.

##### 使用二进制数据记录格式

* `struct`模块提供了`pack()`和`unpack()`函数,用于处理不定长度的二进制记录格式.

##### 多线程

1. 线程是一种对于非顺序依赖的多个任务进行解耦的技术.多线程可以提高应用的响应效率,当接收用户输入的同时,保持其他任务在后台运行.一个有关的应用场景是,将I/O和计算运行在两个并行的线程中.
2. 多线程应用面临的主要挑战是,相互协调的多个线程之间需要共享数据或其他资源.为此,`threading`模块提供了多个同步操作原语,包括线程锁、事件、条件变量和信号量.
3. 实现多任务协作的首选方法是将对资源的所有请求集中到一个线程中,然后使用`queue`模块向该线程供应来自其他线程的请求.应用程序使用`Queue`对象进行线程间通信和协调,更易于设计,更易读,更可靠.

##### 日志

1. `logging`模块提供功能齐全且灵活的日志记录系统.在最简单的情况下,日志消息被发送到文件或`sys.stderr`.
2. 默认情况下,informational和debugging消息被压制,输出会发送到标准错误流.其他输出选项包括将消息转发到电子邮件,数据报,套接字或HTTP服务器.新的过滤器可以根据消息优先级选择不同的路由方式:DEBUG,INFO,WARNING,ERROR,和CRITICAL.
3. 日志系统可以直接从Python配置,也可以从用户配置文件加载,以便自定义日志记录而无需更改应用程序.

##### 弱引用

1. Python会自动进行内存管理(对大多数对象进行引用计数并使用`garbage collection`(`gc`模块,垃圾回收器)来清除循环引用).当某个对象的最后一个引用被移除后不久就会释放其所占用的内存.
2. 此方式对大多数应用来说都适用,但偶尔也必须在对象持续被其他对象所使用时跟踪它们.不幸的是,跟踪它们将创建一个会令其永久化的引用.
3. `weakref`模块提供的工具可以不必创建引用就能跟踪对象.当对象不再需要时,它将自动从一个弱引用表中被移除,并为弱引用对象触发一个回调.典型应用包括对创建开销较大的对象进行缓存.

##### 用于操作列表的工具

1. 许多对于数据结构的需求可以通过内置列表类型来满足.但是,有时也会需要具有不同效费比的替代实现.
2. `array`模块提供了一种array()对象,它类似于列表,但只能存储类型一致的数据且存储密集更高.存储为标准Python的int对象通常要占用16个字节.
3. `collections`模块提供了一种`deque()`对象,它类似于列表,但从左端添加和弹出的速度较快,而在中间查找的速度较慢.此种对象适用于实现队列和广度优先树搜索.
4. `bisect`模块具有用于操作排序列表的函数.
5. `heapq`模块提供了基于常规列表来实现堆的函数.最小值的条目总是保持在位置零.这对于需要重复访问最小元素而不希望运行完整列表排序的应用来说非常有用.

##### 十进制浮点运算

1. `decimal`模块提供了一种Decimal数据类型用于十进制浮点运算.相比内置的float二进制浮点实现,该类特别适用于:
   1. 财务应用和其他需要精确十进制表示的用途;
   2. 控制精度;
   3. 控制四舍五入以满足法律或监管要求;
   4. 跟踪有效小数位;
   5. 用户期望结果与手工完成的计算相匹配的应用程序.
2. Decimal表示的结果会保留尾部的零,并根据具有两个有效位的被乘数自动推出四个有效位.Decimal可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题.
3. 精确表示特性使得Decimal类能够执行对于二进制浮点数来说不适用的模运算和相等性检测.
4. `decimal`模块提供了运算所需要的足够精度

    ```py
    getcontext().prec = 36
    Decimal(1) / Decimal(7)
    ```

#### 12虚拟环境和包

> 一个Python安装可能无法满足每个应用程序的要求.应用程序可能需要特定版本的包的支持.

##### 创建虚拟环境

1. 用于创建和管理虚拟环境的模块称为`venv`.venv通常会安装你可用的最新版本的Python.
2. 创建虚拟环境`python3 -m venv tutorial-env`.如果tutorial-env不存在,将创建它.
3. 激活环境

    ```txt
    windows
    tutorial-env\Scripts\activate.bat
    unix
    source tutorial-env/bin/activate
    ```

##### 使用pip管理包

1. `pip search some`搜索包.
2. `pip install requests==2.6.0`安装包.
3. `pip uninstall some`卸载包.
4. `pip show some`显示特定包的信息.
5. `pip list`显示安装的所有包.
6. `pip freeze > requirements.txt`将生成一个类似的已安装包列表,输出使用pip install期望的格式.
7. `pip install -r requirements.txt`批量安装包.

#### 13接下来

1. python标准库
2. 安装python模块
3. python语言参考
4. [python官网](https://www.python.org)
5. [python文档](https://docs.python.org)
6. [pypi](https://pypi.org)
7. [python cookbook](https://code.activestate.com/recipes/langs/python/),重点部分整理在《python cookbook》一书中.
8. [会议和用户组会议相关视频](http://www.pyvideo.org)
9. [scipy项目](https://scipy.org)

#### 14交互式编辑和编辑历史

##### TAB补全和编辑历史

##### 默认交互式解释器的替代品

1. IPYTHON
2. BPYTHON

#### 15浮点算术:争议和限制

1. 浮点数在计算机硬件中表示为以2为基数(二进制)的小数.
2. 大多数的十进制小数都不能精确地表示为二进制小数.
3. 十进制浮点数都只能近似地以二进制浮点数形式储存在计算机中.
4. 浮点数都只能近似地使用二进制小数表示,对应分数的分子使用每8字节的前53位表示,分母则表示为2的幂次.在1/10这个例子中,相应的二进制分数是3602879701896397/2 ** 55,它很接近1/10,但并不是1/10.
5. 在历史上,Python提示符和内置的repr()函数会选择具有17位有效数字的来显示,即0.10000000000000001.从Python 3.1开始,Python(在大多数系统上)现在能够选择这些表示中最短的并简单地显示0.1.
6. 精确十进制`decimal`模块.
7. 有理数算术运算`fractions`模块.
8. `float.as_integer_radio()`转化为分数表示.
9. `floa.hex()`返回计算机中的精确值.
10. `math.fsum()`函数,它有助于减少求和过程中的精度损失.它会在数值被添加到总计值的时候跟踪"丢失的位".

##### 表示性错误

1. `表示性错误`是指某些(其实是大多数)十进制小数无法以二进制(以2为基数的计数制)精确表示这一事实造成的错误.
2. 将0.1表示为`J/2**N`形式的最接近分数,J为恰好包含53个二进制位的整数.
   1. `1/10 ~= J/(2**N)`.
   2. `J~=2**N/10`.
   3. `2**52<= 2**56 //10 <2**53`,所以N取56.
   4. `q, r = divmod(2**56, 10)`,r=6超过10的一半,因此q+1=7205759403792794.
   5. 因此结果为`7205759403792794 / 2**56`>>>`3602879701896397 / 2 ** 55`.

#### 16附录

##### 交互模式

1. 错误处理
   1. 当发生错误时,解释器会打印错误信息和错误堆栈.在交互模式下,将返回到主命令提示符;如果输入内容来自文件,在打印错误堆栈之后,程序会以非零状态退出.
   2. 所有错误信息都会被写入标准错误流;而命令的正常输出则被写入标准输出流.
   3. 将中断字符(通常为Control-C或Delete)键入主要或辅助提示会取消输入并返回主提示符.在执行命令时键入中断引发的`KeyboardInterrupt`异常,可以由try语句处理.
2. 可执行的Python脚本
   1. 在BSD等类Unix系统上,Python脚本可以直接执行,就像shell脚本一样.
   2. 在文件开头第一行添加`#!/usr/bin/env python`.
   3. 在windows系统上直接双击运行.
3. 交互式启动文件
   1. 当以交互方式使用Python时,每次启动解释器时都会执行一些标准命令,这通常很方便.可以通过将名为`PYTHONSTARTUP`的环境变量设置为包含启动命令的文件名来实现.
4. 定制模块
   1. Python提供了两个钩子来让你自定义它:`sitecustomize`和`usercustomize`.
   2. 在site-packages目录下创建一个名`usercustomize.py`的文件,并将所需内容放入其中.它会影响Python的每次启动,除非它以`-s`选项启动,以禁用自动导入.
   3. `sitecustomize`以相同的方式工作,但通常由计算机管理员在全局`site-packages`目录中创建,并在`usercustomize`之前被导入.

## >>>2Python语言参考

### 19-4-6

#### 1概述

* 对Python编程语言的描述,并不适宜作为教程使用.

##### 其他实现

1. CPython,最早出现并持续维护,以C语言编写.新的语言特性通常在此率先添加.
2. Jython,以 Java 语言编写的 Python 实现.此实现可以作为 Java 应用的一个脚本语言,或者可以用来创建需要 Java 类库支持的应用.
3. Python for .NET,此实现实际上使用了 CPython 实现,但是属于 .NET 托管应用并且可以引入 .NET 类库.
4. IronPython,另一个 .NET 的 Python 实现,与 Python.NET 不同点在于它是生成 IL 的完全 Python 实现,并且将 Python 代码直接编译为 .NET 程序集.
5. PyPy,完全使用 Python 语言编写的 Python 实现.它支持多个其他实现所没有的高级特性,例如非栈式支持和 JIT 编译器等.此项目的目标之一是通过允许方便地修改解释器 (因为它是用 Python 编写的),鼓励该对语言本身进行试验.

##### 标注

1. 句法和词法解析的描述采用经过改进的 BNF 语法标注.这包含以下定义样式:

    ```py
    name      ::= lc_letter(lc_letter | "_")*
    lc_letter ::= "a"..."z"
    ```

    第一行表示name是一个lc_letter之后跟零个或多个lc_letter和下划线.而一个lc_letter则是任意个“a”至“z”字符.

2. 每条规则的开头是一个名称 (即该规则所定义的名称) 加上 ::=.
    1. 竖线 (|) 被用来分隔可选项;它是此标注中最灵活的操作符.
    2. 星号 (\*) 表示前一项的零次或多次重复;
    3. 加号 (+) 表示一次或多次重复;
    4. 由方括号括起的内容 ([ ]) 表示出现零次或一次 (或者说,这部分内容是可选的).
    5. \* 和 + 操作符的绑定是最紧密的;圆括号用于分组.
    6. 固定字符串包含在引号内.
    7. 空格的作用仅限于分隔形符.
    8. 每条规则通常为一行;
    9. 有许多个可选项的规则可能会以竖线为界分为多行.
3. 在词法定义中,还额外使用了两个约定:
    1. 由三个点号分隔的两个本义字符表示在指定 (开) 区间范围内的任意单个 ASCII 字符.
    2. 由尖括号 (<...>) 括起来的内容是对于所定义符号的非正式描述;即可以在必要时用来说明 '控制字符' 的意图.
4. 虽然所用的标注方式几乎相同,但是词法定义和句法定义是存在很大区别的: 词法定义作用于输入源中单独的字符,而句法定义则作用于由词法分析所生成的形符流.
